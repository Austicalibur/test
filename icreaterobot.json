{"MAX30105.cpp":"/***************************************************\n  This is a library written for the Maxim MAX30105 Optical Smoke Detector\n  It should also work with the MAX30102. However, the MAX30102 does not have a Green LED.\n\n  These sensors use I2C to communicate, as well as a single (optional)\n  interrupt line that is not currently supported in this driver.\n\n  Written by Peter Jansen and Nathan Seidle (SparkFun)\n  BSD license, all text above must be included in any redistribution.\n *****************************************************/\n\n#include \"MAX30105.h\"\n\n#ifndef __MICROBIT_H_\n#define __MICROBIT_H_\n#include \"MicroBit.h\"\n#endif\n\n//static MicroBitI2C i2c(I2C_SDA0, I2C_SCL0);\n\nint16_t placeholder;\n\nstatic const char MAX30105_ADDRESS = 0xAE;\n\n\n// Status Registers\nstatic const char MAX30105_INTSTAT1 =\t\t0x00;\nstatic const char MAX30105_INTSTAT2 =\t\t0x01;\nstatic const char MAX30105_INTENABLE1 =\t\t0x02;\nstatic const char MAX30105_INTENABLE2 =\t\t0x03;\n\n// FIFO Registers\nstatic const char MAX30105_FIFOWRITEPTR = \t0x04;\nstatic const char MAX30105_FIFOOVERFLOW = \t0x05;\nstatic const char MAX30105_FIFOREADPTR = \t0x06;\nstatic const char MAX30105_FIFODATA =\t\t0x07;\n\n// Configuration Registers\nstatic const char MAX30105_FIFOCONFIG = \t\t0x08;\nstatic const char MAX30105_MODECONFIG = \t\t0x09;\nstatic const char MAX30105_PARTICLECONFIG = \t0x0A;    // Note, sometimes listed as \"SPO2\" config in datasheet (pg. 11)\nstatic const char MAX30105_LED1_PULSEAMP = \t0x0C;\nstatic const char MAX30105_LED2_PULSEAMP = \t0x0D;\nstatic const char MAX30105_MULTILEDCONFIG1 = 0x11;\nstatic const char MAX30105_MULTILEDCONFIG2 = 0x12;\n\n// Die Temperature Registers\nstatic const char MAX30105_DIETEMPINT = \t\t0x1F;\nstatic const char MAX30105_DIETEMPFRAC = \t0x20;\nstatic const char MAX30105_DIETEMPCONFIG = \t0x21;\n\n// Proximity Function Registers\nstatic const char MAX30105_PROXINTTHRESH = \t0x30;\n\n// Part ID Registers\nstatic const char MAX30105_REVISIONID = \t\t0xFE;\nstatic const char MAX30105_PARTID = \t\t\t0xFF;    // Should always be 0x15. Identical to MAX30102.\n\n// MAX30105 Commands\n// Interrupt configuration (pg 13, 14)\nstatic const char MAX30105_INT_A_FULL_MASK =\t\t(char)~0b10000000;\nstatic const char MAX30105_INT_A_FULL_ENABLE = \t0x80;\nstatic const char MAX30105_INT_A_FULL_DISABLE = \t0x00;\n\nstatic const char MAX30105_INT_DATA_RDY_MASK = (char)~0b01000000;\nstatic const char MAX30105_INT_DATA_RDY_ENABLE =\t0x40;\nstatic const char MAX30105_INT_DATA_RDY_DISABLE = 0x00;\n\nstatic const char MAX30105_INT_ALC_OVF_MASK = (char)~0b00100000;\nstatic const char MAX30105_INT_ALC_OVF_ENABLE = \t0x20;\nstatic const char MAX30105_INT_ALC_OVF_DISABLE = 0x00;\n\nstatic const char MAX30105_INT_PROX_INT_MASK = (char)~0b00010000;\nstatic const char MAX30105_INT_PROX_INT_ENABLE = 0x10;\nstatic const char MAX30105_INT_PROX_INT_DISABLE = 0x00;\n\nstatic const char MAX30105_INT_DIE_TEMP_RDY_MASK = (char)~0b00000010;\nstatic const char MAX30105_INT_DIE_TEMP_RDY_ENABLE = 0x02;\nstatic const char MAX30105_INT_DIE_TEMP_RDY_DISABLE = 0x00;\n\nstatic const char MAX30105_SAMPLEAVG_MASK =\t(char)~0b11100000;\nstatic const char MAX30105_SAMPLEAVG_1 = \t0x00;\nstatic const char MAX30105_SAMPLEAVG_2 = \t0x20;\nstatic const char MAX30105_SAMPLEAVG_4 = \t0x40;\nstatic const char MAX30105_SAMPLEAVG_8 = \t0x60;\nstatic const char MAX30105_SAMPLEAVG_16 = \t0x80;\nstatic const char MAX30105_SAMPLEAVG_32 = \t0xA0;\n\nstatic const char MAX30105_ROLLOVER_MASK = \t0xEF;\nstatic const char MAX30105_ROLLOVER_ENABLE = 0x10;\nstatic const char MAX30105_ROLLOVER_DISABLE = 0x00;\n\nstatic const char MAX30105_A_FULL_MASK = \t0xF0;\n\n// Mode configuration commands (page 19)\nstatic const char MAX30105_SHUTDOWN_MASK = \t0x7F;\nstatic const char MAX30105_SHUTDOWN = \t\t0x80;\nstatic const char MAX30105_WAKEUP = \t\t\t0x00;\n\nstatic const char MAX30105_RESET_MASK = \t\t0xBF;\nstatic const char MAX30105_RESET = \t\t\t0x40;\n\nstatic const char MAX30105_MODE_MASK = \t\t0xF8;\nstatic const char MAX30105_MODE_REDONLY = \t0x02;\nstatic const char MAX30105_MODE_REDIRONLY = \t0x03;\n\n// Particle sensing configuration commands (pgs 19-20)\nstatic const char MAX30105_ADCRANGE_MASK = \t0x9F;\nstatic const char MAX30105_ADCRANGE_2048 = \t0x00;\nstatic const char MAX30105_ADCRANGE_4096 = \t0x20;\nstatic const char MAX30105_ADCRANGE_8192 = \t0x40;\nstatic const char MAX30105_ADCRANGE_16384 = \t0x60;\n\nstatic const char MAX30105_SAMPLERATE_MASK = 0xE3;\nstatic const char MAX30105_SAMPLERATE_50 = \t0x00;\nstatic const char MAX30105_SAMPLERATE_100 = \t0x04;\nstatic const char MAX30105_SAMPLERATE_200 = \t0x08;\nstatic const char MAX30105_SAMPLERATE_400 = \t0x0C;\nstatic const char MAX30105_SAMPLERATE_800 = \t0x10;\nstatic const char MAX30105_SAMPLERATE_1000 = 0x14;\nstatic const char MAX30105_SAMPLERATE_1600 = 0x18;\nstatic const char MAX30105_SAMPLERATE_3200 = 0x1C;\n\nstatic const char MAX30105_PULSEWIDTH_MASK = 0xFC;\nstatic const char MAX30105_PULSEWIDTH_69 = \t0x00;\nstatic const char MAX30105_PULSEWIDTH_118 = \t0x01;\nstatic const char MAX30105_PULSEWIDTH_215 = \t0x02;\nstatic const char MAX30105_PULSEWIDTH_411 = \t0x03;\n\n//Multi-LED Mode configuration (pg 22)\nstatic const char MAX30105_SLOT1_MASK = \t\t0xF8;\nstatic const char MAX30105_SLOT2_MASK = \t\t0x8F;\nstatic const char MAX30105_SLOT3_MASK = \t\t0xF8;\nstatic const char MAX30105_SLOT4_MASK = \t\t0x8F;\n\nstatic const char SLOT_NONE = \t\t\t\t0x00;\nstatic const char SLOT_RED_LED = \t\t\t0x01;\nstatic const char SLOT_IR_LED = \t\t\t\t0x02;\nstatic const char SLOT_GREEN_LED = \t\t\t0x03;\nstatic const char SLOT_NONE_PILOT = \t\t\t0x04;\nstatic const char SLOT_RED_PILOT =\t\t\t0x05;\nstatic const char SLOT_IR_PILOT = \t\t\t0x06;\nstatic const char SLOT_GREEN_PILOT = \t\t0x07;\n\nstatic const char MAX_30105_EXPECTEDPARTID = 0x15;\n\nuint8_t activeDiodes = 3; //Gets set during setup. Allows check() to calculate how many bytes to read from FIFO\n\n#define STORAGE_SIZE 4 //Each long is 4 bytes so limit this to fit on your micro\n\nint16_t IR_AC_Max = 20;\nint16_t IR_AC_Min = -20;\n\nint16_t IR_AC_Signal_Current = 0;\nint16_t IR_AC_Signal_Previous;\nint16_t IR_AC_Signal_min = 0;\nint16_t IR_AC_Signal_max = 0;\nint16_t IR_Average_Estimated;\n\nint16_t positiveEdge = 0;\nint16_t negativeEdge = 0;\nint32_t ir_avg_reg = 0;\n\nint16_t cbuf[32];\nuint8_t offset = 0;\n\nstatic const uint16_t FIRCoeffs[12] = {172, 321, 579, 927, 1360, 1858, 2390, 2916, 3391, 3768, 4012, 4096};\n\ntypedef struct Record\n{\n  uint32_t red[STORAGE_SIZE];\n  uint32_t IR[STORAGE_SIZE];\n  uint32_t green[STORAGE_SIZE];\n  uint8_t head;\n  uint8_t tail;\n} sense_struct; //This is our circular buffer of readings from the sensor\n\nsense_struct sense;\n\nMAX30105::MAX30105() {\n  // Constructor\n}\n\nvoid MAX30105::beginParticle() {\n\n  // Step 1: Initial Communication and Verification\n  // Check that a MAX30105 is connected\n  if (readPartID() != MAX_30105_EXPECTEDPARTID) {\n    // Error -- Part ID read from MAX30105 does not match expected part ID.\n    // This may mean there is a physical connectivity problem (broken wire, unpowered, etc).\n  }\n\n  // Populate revision ID\n  readRevisionID();\n  \n}\n\n//\n// Configuration\n//\n\n//Begin Interrupt configuration\nuint8_t MAX30105::getINT1(void) {\n  return (readRegister8(MAX30105_ADDRESS, MAX30105_INTSTAT1));\n}\nuint8_t MAX30105::getINT2(void) {\n  return (readRegister8(MAX30105_ADDRESS, MAX30105_INTSTAT2));\n}\n\nvoid MAX30105::enableAFULL(void) {\n  bitMask(MAX30105_INTENABLE1, MAX30105_INT_A_FULL_MASK, MAX30105_INT_A_FULL_ENABLE);\n}\nvoid MAX30105::disableAFULL(void) {\n  bitMask(MAX30105_INTENABLE1, MAX30105_INT_A_FULL_MASK, MAX30105_INT_A_FULL_DISABLE);\n}\n\nvoid MAX30105::enableDATARDY(void) {\n  bitMask(MAX30105_INTENABLE1, MAX30105_INT_DATA_RDY_MASK, MAX30105_INT_DATA_RDY_ENABLE);\n}\nvoid MAX30105::disableDATARDY(void) {\n  bitMask(MAX30105_INTENABLE1, MAX30105_INT_DATA_RDY_MASK, MAX30105_INT_DATA_RDY_DISABLE);\n}\n\nvoid MAX30105::enableALCOVF(void) {\n  bitMask(MAX30105_INTENABLE1, MAX30105_INT_ALC_OVF_MASK, MAX30105_INT_ALC_OVF_ENABLE);\n}\nvoid MAX30105::disableALCOVF(void) {\n  bitMask(MAX30105_INTENABLE1, MAX30105_INT_ALC_OVF_MASK, MAX30105_INT_ALC_OVF_DISABLE);\n}\n\nvoid MAX30105::enablePROXINT(void) {\n  bitMask(MAX30105_INTENABLE1, MAX30105_INT_PROX_INT_MASK, MAX30105_INT_PROX_INT_ENABLE);\n}\nvoid MAX30105::disablePROXINT(void) {\n  bitMask(MAX30105_INTENABLE1, MAX30105_INT_PROX_INT_MASK, MAX30105_INT_PROX_INT_DISABLE);\n}\n\nvoid MAX30105::enableDIETEMPRDY(void) {\n  bitMask(MAX30105_INTENABLE2, MAX30105_INT_DIE_TEMP_RDY_MASK, MAX30105_INT_DIE_TEMP_RDY_ENABLE);\n}\nvoid MAX30105::disableDIETEMPRDY(void) {\n  bitMask(MAX30105_INTENABLE2, MAX30105_INT_DIE_TEMP_RDY_MASK, MAX30105_INT_DIE_TEMP_RDY_DISABLE);\n}\n\n//End Interrupt configuration\n\nvoid MAX30105::softReset(void) {\n  bitMask(MAX30105_MODECONFIG, MAX30105_RESET_MASK, MAX30105_RESET);\n\n  // Poll for bit to clear, reset is then complete\n  // Timeout after 100ms\n  unsigned long startTime = system_timer_current_time();\n  while (system_timer_current_time() - startTime < 100)\n  {\n    uint8_t response = readRegister8(MAX30105_ADDRESS, MAX30105_MODECONFIG);\n    if ((response & MAX30105_RESET) == 0) break; //We're done!\n    fiber_sleep(1); //Let's not over burden the I2C bus\n  }\n}\n\nvoid MAX30105::shutDown(void) {\n  // Put IC into low power mode (datasheet pg. 19)\n  // During shutdown the IC will continue to respond to I2C commands but will\n  // not update with or take new readings (such as temperature)\n  bitMask(MAX30105_MODECONFIG, MAX30105_SHUTDOWN_MASK, MAX30105_SHUTDOWN);\n}\n\nvoid MAX30105::wakeUp(void) {\n  // Pull IC out of low power mode (datasheet pg. 19)\n  bitMask(MAX30105_MODECONFIG, MAX30105_SHUTDOWN_MASK, MAX30105_WAKEUP);\n}\n\nvoid MAX30105::setLEDMode(uint8_t mode) {\n  // Set which LEDs are used for sampling -- Red only, RED+IR only, or custom.\n  // See datasheet, page 19\n  activeDiodes = mode - 1;\n  bitMask(MAX30105_MODECONFIG, MAX30105_MODE_MASK, mode);\n}\n\nvoid MAX30105::setADCRange(uint8_t adcRange) {\n  // adcRange: one of MAX30105_ADCRANGE_2048, _4096, _8192, _16384\n  bitMask(MAX30105_PARTICLECONFIG, MAX30105_ADCRANGE_MASK, adcRange);\n}\n\nvoid MAX30105::setSampleRate(uint8_t sampleRate) {\n  // sampleRate: one of MAX30105_SAMPLERATE_50, _100, _200, _400, _800, _1000, _1600, _3200\n  bitMask(MAX30105_PARTICLECONFIG, MAX30105_SAMPLERATE_MASK, sampleRate);\n}\n\nvoid MAX30105::setPulseWidth(uint8_t pulseWidth) {\n  // pulseWidth: one of MAX30105_PULSEWIDTH_69, _188, _215, _411\n  bitMask(MAX30105_PARTICLECONFIG, MAX30105_PULSEWIDTH_MASK, pulseWidth);\n}\n\n// NOTE: Amplitude values: 0x00 = 0mA, 0x7F = 25.4mA, 0xFF = 50mA (typical)\n// See datasheet, page 21\nvoid MAX30105::setPulseAmplitudeRed(uint8_t amplitude) {\n  writeRegister8(MAX30105_ADDRESS, MAX30105_LED1_PULSEAMP, amplitude);\n}\n\nvoid MAX30105::setPulseAmplitudeIR(uint8_t amplitude) {\n  writeRegister8(MAX30105_ADDRESS, MAX30105_LED2_PULSEAMP, amplitude);\n}\n\nvoid MAX30105::setProximityThreshold(uint8_t threshMSB) {\n  // Set the IR ADC count that will trigger the beginning of particle-sensing mode.\n  // The threshMSB signifies only the 8 most significant-bits of the ADC count.\n  // See datasheet, page 24.\n  writeRegister8(MAX30105_ADDRESS, MAX30105_PROXINTTHRESH, threshMSB);\n}\n\n//Given a slot number assign a thing to it\n//Devices are SLOT_RED_LED or SLOT_RED_PILOT (proximity)\n//Assigning a SLOT_RED_LED will pulse LED\n//Assigning a SLOT_RED_PILOT will ??\nvoid MAX30105::enableSlot(uint8_t slotNumber, uint8_t device) {\n\n  switch (slotNumber) {\n    case (1):\n      bitMask(MAX30105_MULTILEDCONFIG1, MAX30105_SLOT1_MASK, device);\n      break;\n    case (2):\n      bitMask(MAX30105_MULTILEDCONFIG1, MAX30105_SLOT2_MASK, device << 4);\n      break;\n    case (3):\n      bitMask(MAX30105_MULTILEDCONFIG2, MAX30105_SLOT3_MASK, device);\n      break;\n    case (4):\n      bitMask(MAX30105_MULTILEDCONFIG2, MAX30105_SLOT4_MASK, device << 4);\n      break;\n    default:\n      //Shouldn't be here!\n      break;\n  }\n}\n\n//Clears all slot assignments\nvoid MAX30105::disableSlots(void) {\n  writeRegister8(MAX30105_ADDRESS, MAX30105_MULTILEDCONFIG1, 0);\n  writeRegister8(MAX30105_ADDRESS, MAX30105_MULTILEDCONFIG2, 0);\n}\n\n//\n// FIFO Configuration\n//\n\n//Set sample average (Table 3, Page 18)\nvoid MAX30105::setFIFOAverage(uint8_t numberOfSamples) {\n  bitMask(MAX30105_FIFOCONFIG, MAX30105_SAMPLEAVG_MASK, numberOfSamples);\n}\n\n//Resets all points to start in a known state\n//Page 15 recommends clearing FIFO before beginning a read\nvoid MAX30105::clearFIFO(void) {\n  writeRegister8(MAX30105_ADDRESS, MAX30105_FIFOWRITEPTR, 0);\n  writeRegister8(MAX30105_ADDRESS, MAX30105_FIFOOVERFLOW, 0);\n  writeRegister8(MAX30105_ADDRESS, MAX30105_FIFOREADPTR, 0);\n}\n\n//Enable roll over if FIFO over flows\nvoid MAX30105::enableFIFORollover(void) {\n  bitMask(MAX30105_FIFOCONFIG, MAX30105_ROLLOVER_MASK, MAX30105_ROLLOVER_ENABLE);\n}\n\n//Disable roll over if FIFO over flows\nvoid MAX30105::disableFIFORollover(void) {\n  bitMask(MAX30105_FIFOCONFIG, MAX30105_ROLLOVER_MASK, MAX30105_ROLLOVER_DISABLE);\n}\n\n//Set number of samples to trigger the almost full interrupt (Page 18)\n//Power on default is 32 samples\n//Note it is reverse: 0x00 is 32 samples, 0x0F is 17 samples\nvoid MAX30105::setFIFOAlmostFull(uint8_t numberOfSamples) {\n  bitMask(MAX30105_FIFOCONFIG, MAX30105_A_FULL_MASK, numberOfSamples);\n}\n\n//Read the FIFO Write Pointer\nuint8_t MAX30105::getWritePointer(void) {\n  return (readRegister8(MAX30105_ADDRESS, MAX30105_FIFOWRITEPTR));\n}\n\n//Read the FIFO Read Pointer\nuint8_t MAX30105::getReadPointer(void) {\n  return (readRegister8(MAX30105_ADDRESS, MAX30105_FIFOREADPTR));\n}\n\n\n// Die Temperature\n// Returns temp in C\nfloat MAX30105::readTemperature() {\n\t\n  //DIE_TEMP_RDY interrupt must be enabled\n  //See issue 19: https://github.com/sparkfun/SparkFun_MAX3010x_Sensor_Library/issues/19\n  \n  // Step 1: Config die temperature register to take 1 temperature sample\n  writeRegister8(MAX30105_ADDRESS, MAX30105_DIETEMPCONFIG, 0x01);\n\n  // Poll for bit to clear, reading is then complete\n  // Timeout after 100ms\n  unsigned long startTime = system_timer_current_time();\n  while (system_timer_current_time() - startTime < 100)\n  {\n    //uint8_t response = readRegister8(MAX30105_ADDRESS, MAX30105_DIETEMPCONFIG); //Original way\n    //if ((response & 0x01) == 0) break; //We're done!\n    \n\t//Check to see if DIE_TEMP_RDY interrupt is set\n\tuint8_t response = readRegister8(MAX30105_ADDRESS, MAX30105_INTSTAT2);\n    if ((response & MAX30105_INT_DIE_TEMP_RDY_ENABLE) > 0) break; //We're done!\n    fiber_sleep(1); //Let's not over burden the I2C bus\n  }\n  //TODO How do we want to fail? With what type of error?\n  //? if(uBit.systemTime() - startTime >= 100) return(-999.0);\n\n  // Step 2: Read die temperature register (integer)\n  int8_t tempInt = readRegister8(MAX30105_ADDRESS, MAX30105_DIETEMPINT);\n  uint8_t tempFrac = readRegister8(MAX30105_ADDRESS, MAX30105_DIETEMPFRAC); //Causes the clearing of the DIE_TEMP_RDY interrupt\n\n  // Step 3: Calculate temperature (datasheet pg. 23)\n  return (float)tempInt + ((float)tempFrac * 0.0625);\n}\n\n// Returns die temp in F\nfloat MAX30105::readTemperatureF() {\n  float temp = readTemperature();\n\n  if (temp != -999.0) temp = temp * 1.8 + 32.0;\n\n  return (temp);\n}\n\n// Set the PROX_INT_THRESHold\nvoid MAX30105::setPROXINTTHRESH(uint8_t val) {\n  writeRegister8(MAX30105_ADDRESS, MAX30105_PROXINTTHRESH, val);\n}\n\n\n//\n// Device ID and Revision\n//\nuint8_t MAX30105::readPartID() {\n  return readRegister8(MAX30105_ADDRESS, MAX30105_PARTID);\n}\n\nvoid MAX30105::readRevisionID() {\n  revisionID = readRegister8(MAX30105_ADDRESS, MAX30105_REVISIONID);\n}\n\nuint8_t MAX30105::getRevisionID() {\n  return revisionID;\n}\n\n\n//Setup the sensor\n//The MAX30105 has many settings. By default we select:\n// Sample Average = 4\n// Mode = MultiLED\n// ADC Range = 16384 (62.5pA per LSB)\n// Sample rate = 50\n//Use the default setup if you are just getting started with the MAX30105 sensor\nvoid MAX30105::setup(uint8_t powerLevel, uint8_t sampleAverage, uint8_t ledMode, int sampleRate, int pulseWidth, int adcRange) {\n  softReset(); //Reset all configuration, threshold, and data registers to POR values\n  //FIFO Configuration\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n  //The chip will average multiple samples of same type together if you wish\n  if (sampleAverage == 1) setFIFOAverage(MAX30105_SAMPLEAVG_1); //No averaging per FIFO record\n  else if (sampleAverage == 2) setFIFOAverage(MAX30105_SAMPLEAVG_2);\n  else if (sampleAverage == 4) setFIFOAverage(MAX30105_SAMPLEAVG_4);\n  else if (sampleAverage == 8) setFIFOAverage(MAX30105_SAMPLEAVG_8);\n  else if (sampleAverage == 16) setFIFOAverage(MAX30105_SAMPLEAVG_16);\n  else if (sampleAverage == 32) setFIFOAverage(MAX30105_SAMPLEAVG_32);\n  else setFIFOAverage(MAX30105_SAMPLEAVG_4);\n\n  //setFIFOAlmostFull(2); //Set to 30 samples to trigger an 'Almost Full' interrupt\n  enableFIFORollover(); //Allow FIFO to wrap/roll over\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n  //Mode Configuration\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n  if (ledMode == 2) setLEDMode(MAX30105_MODE_REDIRONLY); //Red and IR\n  else setLEDMode(MAX30105_MODE_REDONLY); //Red only\n  activeDiodes = ledMode; //Used to control how many uint8_ts to read from FIFO buffer\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n  //Particle Sensing Configuration\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n  if(adcRange < 4096) setADCRange(MAX30105_ADCRANGE_2048); //7.81pA per LSB\n  else if(adcRange < 8192) setADCRange(MAX30105_ADCRANGE_4096); //15.63pA per LSB\n  else if(adcRange < 16384) setADCRange(MAX30105_ADCRANGE_8192); //31.25pA per LSB\n  else if(adcRange == 16384) setADCRange(MAX30105_ADCRANGE_16384); //62.5pA per LSB\n  else setADCRange(MAX30105_ADCRANGE_2048);\n\n  if (sampleRate < 100) setSampleRate(MAX30105_SAMPLERATE_50); //Take 50 samples per second\n  else if (sampleRate < 200) setSampleRate(MAX30105_SAMPLERATE_100);\n  else if (sampleRate < 400) setSampleRate(MAX30105_SAMPLERATE_200);\n  else if (sampleRate < 800) setSampleRate(MAX30105_SAMPLERATE_400);\n  else if (sampleRate < 1000) setSampleRate(MAX30105_SAMPLERATE_800);\n  else if (sampleRate < 1600) setSampleRate(MAX30105_SAMPLERATE_1000);\n  else if (sampleRate < 3200) setSampleRate(MAX30105_SAMPLERATE_1600);\n  else if (sampleRate == 3200) setSampleRate(MAX30105_SAMPLERATE_3200);\n  else setSampleRate(MAX30105_SAMPLERATE_50);\n\n  //The longer the pulse width the longer range of detection you'll have\n  //At 69us and 0.4mA it's about 2 inches\n  //At 411us and 0.4mA it's about 6 inches\n  if (pulseWidth < 118) setPulseWidth(MAX30105_PULSEWIDTH_69); //Page 26, Gets us 15 bit resolution\n  else if (pulseWidth < 215) setPulseWidth(MAX30105_PULSEWIDTH_118); //16 bit resolution\n  else if (pulseWidth < 411) setPulseWidth(MAX30105_PULSEWIDTH_215); //17 bit resolution\n  else if (pulseWidth == 411) setPulseWidth(MAX30105_PULSEWIDTH_411); //18 bit resolution\n  else setPulseWidth(MAX30105_PULSEWIDTH_69);\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n  //LED Pulse Amplitude Configuration\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n  //Default is 0x1F which gets us 6.4mA\n  //powerLevel = 0x02, 0.4mA - Presence detection of ~4 inch\n  //powerLevel = 0x1F, 6.4mA - Presence detection of ~8 inch\n  //powerLevel = 0x7F, 25.4mA - Presence detection of ~8 inch\n  //powerLevel = 0xFF, 50.0mA - Presence detection of ~12 inch\n\n  setPulseAmplitudeRed(powerLevel);\n  setPulseAmplitudeIR(powerLevel);\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n  //Multi-LED Mode Configuration, Enable the reading of the three LEDs\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n  enableSlot(1, SLOT_RED_LED);\n  if (ledMode > 1) enableSlot(2, SLOT_IR_LED);\n  //enableSlot(1, SLOT_RED_PILOT);\n  //enableSlot(2, SLOT_IR_PILOT);\n  //enableSlot(3, SLOT_GREEN_PILOT);\n  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n  clearFIFO(); //Reset the FIFO before we begin checking the sensor\n}\n\t\n//\n// Data Collection\n//\n\n//Tell caller how many samples are available\nuint8_t MAX30105::available(void)\n{\n  int8_t numberOfSamples = sense.head - sense.tail;\n  if (numberOfSamples < 0) numberOfSamples += STORAGE_SIZE;\n\n  return (numberOfSamples);\n}\n\n//Report the most recent red value\nuint32_t MAX30105::getRed(void)\n{\n  //Check the sensor for new data for 250ms\n  if(safeCheck(250)){\n    return sense.red[sense.head];\n  }\n  else\n    return(0); //Sensor failed to find new data\n}\n\n//Report the most recent IR value\nuint32_t MAX30105::getIR(void)\n{\n  //Check the sensor for new data for 250ms\n  if(safeCheck(250))\n    return (sense.IR[sense.head]);\n  else\n    return(0); //Sensor failed to find new data\n}\n\n//Report the most recent Green value\nuint32_t MAX30105::getGreen(void)\n{\n  //Check the sensor for new data for 250ms\n  if(safeCheck(250))\n    return (sense.green[sense.head]);\n  else\n    return(0); //Sensor failed to find new data\n}\n\n//Report the next Red value in the FIFO\nuint32_t MAX30105::getFIFORed(void)\n{\n  return (sense.red[sense.tail]);\n}\n\n//Report the next IR value in the FIFO\nuint32_t MAX30105::getFIFOIR(void)\n{\n  return (sense.IR[sense.tail]);\n}\n\n//Report the next Green value in the FIFO\nuint32_t MAX30105::getFIFOGreen(void)\n{\n  return (sense.green[sense.tail]);\n}\n\n//Advance the tail\nbool MAX30105::nextSample(void)\n{\n  if(available()) //Only advance the tail if new data is available\n  {\n    sense.tail++;\n    sense.tail %= STORAGE_SIZE; //Wrap condition\n\treturn true;\n  }\n  else\n  {\n\treturn false;\n  }\n}\n\n//Polls the sensor for new data\n//Call regularly\n//If new data is available, it updates the head and tail in the main struct\n//Returns number of new samples obtained\nuint16_t MAX30105::check(void)\n{\n  //Read register FIDO_DATA in (3-uint8_t * number of active LED) chunks\n  //Until FIFO_RD_PTR = FIFO_WR_PTR\n\n  uint8_t readPointer = getReadPointer();\n  uint8_t writePointer = getWritePointer();\n  int numberOfSamples = 0;\n\n  //Do we have new data?\n  if (readPointer != writePointer)\n  {\n    //Calculate the number of readings we need to get from sensor\n    numberOfSamples = writePointer - readPointer;\n    if (numberOfSamples < 0) \n\t\tnumberOfSamples += I2C_BUFFER_LENGTH; //Wrap condition\n\n    //We now have the number of readings, now calc uint8_ts to read\n    //For this example we are just doing Red and IR (3 uint8_ts each)\n    uint8_t bytesLeftToRead = numberOfSamples * activeDiodes * 3;\n\n    //Get ready to read a burst of data from the FIFO register\n\n    //We may need to read as many as 288 uint8_ts so we read in blocks no larger than I2C_BUFFER_LENGTH\n    //I2C_BUFFER_LENGTH changes based on the platform. 64 uint8_ts for SAMD21, 32 uint8_ts for Uno.\n    while (bytesLeftToRead > 0)\n    {\n\t\t\n      uint8_t toGet = activeDiodes * 3;\n\n      //Request toGet number of uint8_ts from sensor\n      //i2c.requestFrom(MAX30105_ADDRESS, toGet);\n      while(toGet > 0)\n\t  {\n\t\tuint8_t temp[9]; //Array of 9 uint8_ts that we will convert into longs\n\t\tuint8_t temp2[4];\n        uint32_t tempLong;\n\t\n\t\tuBit.i2c.readRegister(MAX30105_ADDRESS, (uint8_t)MAX30105_FIFODATA, temp, toGet);\n\n        sense.head++; //Advance the head of the storage struct\n        sense.head %= STORAGE_SIZE; //Wrap condition\n\t\tfor (int led = 0; led < activeDiodes; led++)\n\t\t{\n\t\t\tuint8_t checkOffset = led * 3;\n\t\t\ttemp2[3] = 0;\n\t\t\ttemp2[0] = temp[2 + checkOffset];\n\t\t\ttemp2[1] = temp[1 + checkOffset];\n\t\t\ttemp2[2] = temp[checkOffset];\n\t\t\tmemcpy(&tempLong, temp2, sizeof(tempLong)); //tempLong is 4 bytes, we only need 3\n\t\t\ttempLong &= 0x3FFFF;\n\t\t\tswitch (led)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tsense.red[sense.head] = tempLong;//Long;//Store this reading into the sense array\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tsense.IR[sense.head] = tempLong;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsense.green[sense.head] = tempLong;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbytesLeftToRead -= toGet;\n\t\ttoGet -= activeDiodes * 3;\n\t  }\n    } //End while (bytesLeftToRead > 0)\n  } //End readPtr != writePtr\n  return (numberOfSamples); //Let the world know how much new data we found\n}\n\n//Check for new data but give up after a certain amount of time\n//Returns true if new data was found\n//Returns false if new data was not found\nbool MAX30105::safeCheck(uint8_t maxTimeToCheck)\n{\n  uint64_t markTime = system_timer_current_time();\n  \n  while(1)\n  {\n\tif(system_timer_current_time() - markTime > maxTimeToCheck){\n\t\t\n\t\treturn(false);\n\t}\n\n\tif(check() == true)\n\t{ //We found new data!\n\t  return(true);\n\t}\n\tfiber_sleep(1);\n  }\n}\n\n//Given a register, read it, mask it, and then set the thing\nvoid MAX30105::bitMask(uint8_t reg, uint8_t mask, uint8_t thing)\n{\n  // Grab current register context\n  uint8_t originalContents = readRegister8(MAX30105_ADDRESS, reg);\n\n  // Zero-out the portions of the register we're interested in\n  originalContents = originalContents & mask;\n\n  // Change contents\n  writeRegister8(MAX30105_ADDRESS, reg, originalContents | thing);\n}\n\n//  Heart Rate Monitor functions takes a sample value and the sample number\n//  Returns true if a beat is detected\n//  A running average of four samples is recommended for display on the screen.\nbool MAX30105::checkForBeat(uint32_t sample)\n{\n  bool beatDetected = false;\n  \n  //  Save current state\n  IR_AC_Signal_Previous = IR_AC_Signal_Current;\n  \n  //This is good to view for debugging\n  //uBit.serial.send(\"Signal_Current: \");\n  //uBit.serial.send(IR_AC_Signal_Current);\n\n  //  Process next data sample\n  IR_Average_Estimated = averageDCEstimator(&ir_avg_reg, sample);\n  IR_AC_Signal_Current = lowPassFIRFilter(sample - IR_Average_Estimated);\n\n  //  Detect positive zero crossing (rising edge)\n  if ((IR_AC_Signal_Previous < 0) && (IR_AC_Signal_Current >= 0))\n  {\n  \n    IR_AC_Max = IR_AC_Signal_max; //Adjust our AC max and min\n    IR_AC_Min = IR_AC_Signal_min;\n\n    positiveEdge = 1;\n    negativeEdge = 0;\n    IR_AC_Signal_max = 0;\n\n    //if ((IR_AC_Max - IR_AC_Min) > 100 & (IR_AC_Max - IR_AC_Min) < 1000)\n    if (((IR_AC_Max - IR_AC_Min) > 20) && ((IR_AC_Max - IR_AC_Min) < 1000))\n    {\n\t  placeholder++;\n      //Heart beat!!!\n      beatDetected = true;\n    }\n  }\n\n  //  Detect negative zero crossing (falling edge)\n  if ((IR_AC_Signal_Previous > 0) && (IR_AC_Signal_Current <= 0))\n  {\n    positiveEdge = 0;\n    negativeEdge = 1;\n    IR_AC_Signal_min = 0;\n  }\n\n  //  Find Maximum value in positive cycle\n  if (positiveEdge && (IR_AC_Signal_Current > IR_AC_Signal_Previous))\n  {\n    IR_AC_Signal_max = IR_AC_Signal_Current;\n  }\n\n  //  Find Minimum value in negative cycle\n  if (negativeEdge && (IR_AC_Signal_Current < IR_AC_Signal_Previous))\n  {\n    IR_AC_Signal_min = IR_AC_Signal_Current;\n  }\n  \n  return(beatDetected);\n}\n\nint16_t MAX30105::getPlaceholder()\n{\n\treturn placeholder;\n}\n\n//  Average DC Estimator\nint16_t MAX30105::averageDCEstimator(int32_t *p, uint16_t x)\n{\n  *p += ((((long) x << 15) - *p) >> 4);\n  return (*p >> 15);\n}\n\n//  Low Pass FIR Filter\nint16_t MAX30105::lowPassFIRFilter(int16_t din)\n{  \n  cbuf[offset] = din;\n\n  int32_t z = mul16(FIRCoeffs[11], cbuf[(offset - 11) & 0x1F]);\n  \n  for (uint8_t i = 0 ; i < 11 ; i++)\n  {\n    z += mul16(FIRCoeffs[i], cbuf[(offset - i) & 0x1F] + cbuf[(offset - 22 + i) & 0x1F]);\n  }\n\n  offset++;\n  offset %= 32; //Wrap condition\n\n  return(z >> 15);\n}\n\n//  Integer multiplier\nint32_t MAX30105::mul16(int16_t x, int16_t y)\n{\n  return((long)x * (long)y);\n}\n\n//\n// Low-level I2C Communication\n//\nuint8_t MAX30105::readRegister8(uint8_t address, uint8_t reg) {\n\tuint8_t data;\n\tuBit.i2c.readRegister(address, reg, &data, 1);\n\treturn data;\n}\n\nvoid MAX30105::writeRegister8(uint8_t address, uint8_t reg, uint8_t value) {\n\n#if MICROBIT_CODAL\n\tuint8_t temp[2];\n#else \n\tchar temp[2];\n#endif\n\ttemp[0] = reg;\n\tmemcpy(&temp[1], &value, 2); \n\n\tuBit.i2c.write(address, temp, 2);\n\n}\n","MAX30105.h":"/*************************************************** \n This is a library written for the Maxim MAX30105 Optical Smoke Detector\n It should also work with the MAX30102. However, the MAX30102 does not have a Green LED.\n\n These sensors use I2C to communicate, as well as a single (optional)\n interrupt line that is not currently supported in this driver.\n \n Written by Peter Jansen and Nathan Seidle (SparkFun)\n BSD license, all text above must be included in any redistribution.\n *****************************************************/\n\n#pragma once\n\n#ifndef __MBED_H_\n#define __MBED_H_\n#include \"mbed.h\"\n#endif\n\n#include \"pxt.h\"\n\n#define I2C_SPEED_STANDARD        100000\n#define I2C_SPEED_FAST            400000\n\n//The catch-all default is 32\n#define I2C_BUFFER_LENGTH 32\n\nclass MAX30105 {\n public: \n\n  MAX30105(void);\n\n  void beginParticle();\n\n  uint32_t getRed(void); //Returns immediate red value\n  uint32_t getIR(void); //Returns immediate IR value\n  uint32_t getGreen(void); //Returns immediate green value\n  bool safeCheck(uint8_t maxTimeToCheck); //Given a max amount of time, check for new data\n\n  // Configuration\n  void softReset();\n  void shutDown(); \n  void wakeUp(); \n\n  void setLEDMode(uint8_t mode);\n\n  void setADCRange(uint8_t adcRange);\n  void setSampleRate(uint8_t sampleRate);\n  void setPulseWidth(uint8_t pulseWidth);\n\n  void setPulseAmplitudeRed(uint8_t value);\n  void setPulseAmplitudeIR(uint8_t value);\n\n  void setProximityThreshold(uint8_t threshMSB);\n\n  //Multi-led configuration mode (page 22)\n  void enableSlot(uint8_t slotNumber, uint8_t device); //Given slot number, assign a device to slot\n  void disableSlots(void);\n  \n  // Data Collection\n\n  //Interrupts (page 13, 14)\n  uint8_t getINT1(void); //Returns the main interrupt group\n  uint8_t getINT2(void); //Returns the temp ready interrupt\n  void enableAFULL(void); //Enable/disable individual interrupts\n  void disableAFULL(void);\n  void enableDATARDY(void);\n  void disableDATARDY(void);\n  void enableALCOVF(void);\n  void disableALCOVF(void);\n  void enablePROXINT(void);\n  void disablePROXINT(void);\n  void enableDIETEMPRDY(void);\n  void disableDIETEMPRDY(void);\n\n  //FIFO Configuration (page 18)\n  void setFIFOAverage(uint8_t samples);\n  void enableFIFORollover();\n  void disableFIFORollover();\n  void setFIFOAlmostFull(uint8_t samples);\n  \n  //FIFO Reading\n  uint16_t check(void); //Checks for new data and fills FIFO\n  uint8_t available(void); //Tells caller how many new samples are available (head - tail)\n  bool nextSample(void); //Advances the tail of the sense array\n  uint32_t getFIFORed(void); //Returns the FIFO sample pointed to by tail\n  uint32_t getFIFOIR(void); //Returns the FIFO sample pointed to by tail\n  uint32_t getFIFOGreen(void); //Returns the FIFO sample pointed to by tail\n\n  uint8_t getWritePointer(void);\n  uint8_t getReadPointer(void);\n  void clearFIFO(void); //Sets the read/write pointers to zero\n\n  //Proximity Mode Interrupt Threshold\n  void setPROXINTTHRESH(uint8_t val);\n\n  // Die Temperature\n  float readTemperature();\n  float readTemperatureF();\n\n  // Detecting ID/Revision\n  uint8_t getRevisionID();\n  uint8_t readPartID();  \n\n  // Setup the IC with user selectable settings\n  void setup(uint8_t powerLevel, uint8_t sampleAverage, uint8_t ledMode, int sampleRate, int pulseWidth, int adcRange);\n\n  bool checkForBeat(uint32_t sample);\n  int16_t averageDCEstimator(int32_t *p, uint16_t x);\n  int16_t lowPassFIRFilter(int16_t din);\n  int32_t mul16(int16_t x, int16_t y);\n\n  \n  // Low-level I2C communication\n  uint8_t readRegister8(uint8_t address, uint8_t reg);\n  void writeRegister8(uint8_t address, uint8_t reg, uint8_t value);\n\n  int16_t getPlaceholder();\n private:\n  //activeDiodes is the number of channels turned on, and can be 1 to 3. 2 is common for Red+IR.\n  \n  uint8_t revisionID; \n\n  void readRevisionID();\n\n  void bitMask(uint8_t reg, uint8_t mask, uint8_t thing);\n\n\n};\n","README.md":"## Introduction\nCoding Kit for BBC micro:bit is based on the micro:bit main control board and includes sensors, actuators, and other accessories. The set is perfectly designed to integrate with LEGO parts, making it ideal for students to create micro:bit-based technology and creative projects. This document focuses on the main control board, sensors, actuators, and related software extensions.\n\nProduct link https://www.icrobot.com/www/cn/index.html#/product/detail?id=4\n\nTutorials link https://icreaterobot-microbit-docs.readthedocs.io/en/latest/docs/Microbit/index.html\n\n## Code Example\n\ninput.onButtonPressed(Button.A, function () {\n    Microbit.MotorRun(Microbit.enMotors.M2, 0)\n})\nbasic.forever(function () {\n    Microbit.ledRBrightness(Write_pin.w0, true)\n    basic.pause(100)\n    Microbit.ledRBrightness(Write_pin.w0, false)\n    basic.pause(100)\n})\n\n\n## License\nMIT\n\n## Supported targets\nfor PXT/microbit (The metadata above is needed for package search.)\n","_locales/ar/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"أجهزة الاستشعار\",\n    \"{id:subcategory}Movement\": \"الحركة\",\n    \"{id:subcategory}Audio-visual\": \"الصوت والضوء\",\n    \"{id:group}RGB LED Module\": \"وحدة LED RGB\",\n    \"{id:group}OLED Module\": \"وحدة OLED\",\n    \"{id:group}Laser Module\": \"وحدة الليزر\",\n    \"{id:group}Recording Module\": \"وحدة التسجيل\",\n    \"{id:group}Servo Motor\": \"محرك سيرفو\",\n    \"Microbit.rock.orient1|block\": \"أعلى\",\n    \"Microbit.rock.orient2|block\": \"أسفل\",\n    \"Microbit.rock.orient3|block\": \"يسار\",\n    \"Microbit.rock.orient4|block\": \"يمين\",\n    \"PingUnit.Centimeters|block\": \"سنتيمتر\",\n    \"PingUnit.MicroSeconds|block\": \"ميكروثانية\",\n    \"PingUnit.Inches|block\": \"بوصة\",\n    \"Microbit.buttonState|block\": \"مستشعر الزر %buttonpin\",\n    \"Microbit.hState|block\": \"مستشعر هول %hallpin\",\n    \"Microbit.farState|block\": \"مستشعر المسافة البعيدة %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"مستشعر الجهد %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"مستشعر التدرج الرمادي %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"مستشعر شدة الضوء %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"مستشعر اللهب %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"مستشعر مستوى المياه %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"مستشعر الغاز القابل للاشتعال %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"مستشعر رطوبة التربة %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"مستشعر درجة حرارة المياه المقاومة للماء %waterproofpin\",\n    \"Microbit.ping|block\": \"مستشعر الموجات فوق الصوتية %ultpins وحدة %unit\",\n    \"Microbit.pinpullup|block\": \"مستشعر تتبع الخط %pin \",\n    \"Microbit.rocker|block\": \"عصا تحكم %direction اتجاه\",\n    \"Microbit.rockerori|block\": \"تم اكتشاف عصا تحكم %orientation \",\n    \"Microbit.pir|block\": \"مستشعر الحركة بالأشعة تحت الحمراء %pirpin اكتشف الحركة\",\n    \"Microbit.ReadWaterLevel|block\": \"مستشعر مستوى المياه %waterlevelpin\",\n    \"Microbit.enMotorcolor.red|block\": \"أحمر\",\n    \"Microbit.enMotorcolor.blue|block\": \"أخضر\",\n    \"Microbit.enMotorcolor.green|block\": \"أزرق\",\n    \"Microbit.enMotorcolor.yellow|block\": \"أصفر\",\n    \"Microbit.Servo4|block\": \"سيرفو | %num | زاوية %value\",\n    \"Microbit.MotorRun|block\": \"محرك | %index | السرعة (-255 ~ 255) %speed\",\n    \"Microbit.motorFan|block\": \"مروحة %fanpin التبديل إلى $fanstate || السرعة %speed\",\n    \"Microbit.elecmagnet|block\": \"مغناطيس كهربائي %elecpin التبديل إلى %magState || القوة المغناطيسية %force\",\n    \"Microbit.runMotor|block\": \"| %motoraddress | المحرك يدور بسرعة | %speed |\",\n    \"Microbit.runMotor|group\": \"محرك سيرفو\",\n    \"Microbit.Writemotorlocation|block\": \"| %motoraddress | المحرك يدور بسرعة | %speed | إلى الموقع | %location |\",\n    \"Microbit.Writemotorrelativelocation|block\": \"| %motoraddress | المحرك يدور بسرعة | %speed | إلى الموقع | %location | درجة\",\n    \"Microbit.Writemotorrelativetime|block\": \"| %motoraddress | المحرك يدور بسرعة | %speed | لمدة | %time | ثانية\",\n    \"Microbit.runDMotor|block\": \"المحركين المزدوجين يدوران بسرعتين %speed1 %speed2\",\n    \"Microbit.WriteDmotorlocation|block\": \"المحركين المزدوجين يدوران بسرعتين %speed1 %speed2 إلى موقع %location درجة\",\n    \"Microbit.DMotor|block\": \"المحرك الأيسر مع عنوان المحرك | %motoraddress1 | والمحرك الأيمن مع عنوان المحرك | %motoraddress2 |\",\n    \"Microbit.Readmotorspeed|block\": \"قراءة سرعة المحرك | %motoraddress | \",\n    \"Microbit.Readmotorlocation|block\": \"قراءة موقع المحرك | %motoraddress |\",\n    \"Microbit.writeDmotortime|block\": \"المحركين المزدوجين يدوران بسرعتين %speed1 %speed2 لمدة %time ثانية\",\n    \"Record_list.rl1|block\": \"إطلاق رشاش\",\n    \"Record_list.rl2|block\": \"إطلاق ليزر\",\n    \"Record_list.rl3|block\": \"تسريع سيارة\",\n    \"Record_list.rl4|block\": \"بدء الحرب\",\n    \"Record_list.rl5|block\": \"العد التنازلي\",\n    \"Record_list.rl6|block\": \"تسجيل الصوت\",\n    \"Microbit.Record_id|block\": \"وحدة التسجيل-تشغيل %recordID \",\n    \"Microbit.laserController|block\": \"ليزر %laserpin التبديل إلى %laserState || ليزر %intensity\",\n    \"Microbit.showString|block\": \"عرض نص اختر الموقع %oled | نص %s\",\n    \"Microbit.showNumber|block\": \"عرض رقم اختر الموقع %oled | رقم %num\",\n    \"Microbit.showStringxy|block\": \"عرض نص في x %x | y %y | نص %s | لون %color\",\n    \"Microbit.showNumberxy|block\": \"عرض رقم في x %x | y %y | رقم %num | لون %color\",\n    \"Microbit.clear|block\": \"مسح\",\n    \"Microbit.init|block\": \"تهيئة OLED \",\n    \"NeoPixelColors.Red|block\": \"أحمر\",\n    \"NeoPixelColors.Orange|block\": \"برتقالي\",\n    \"NeoPixelColors.Yellow|block\": \"أصفر\",\n    \"NeoPixelColors.Green|block\": \"أخضر\",\n    \"NeoPixelColors.Blue|block\": \"أزرق\",\n    \"NeoPixelColors.Indigo|block\": \"نيلي\",\n    \"NeoPixelColors.Violet|block\": \"بنفسجي\",\n    \"NeoPixelColors.Purple|block\": \"أرجواني\",\n    \"NeoPixelColors.White|block\": \"أبيض\",\n    \"NeoPixelColors.Black|block\": \"أسود\",\n    \"Microbit.Strip.showColor|block\": \"%strip | عرض اللون %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip | عرض قوس قزح من %startHue إلى %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip | تعيين السطوع %brightness\",\n    \"Microbit.create|block\": \"استخدام %neopixelpin  لحلقة الضوء\",\n    \"Microbit.rgb|block\": \"أحمر %red | أخضر %green | أزرق %blue\",\n    \"Microbit.colors|block\": \"%color\",\n    \"Microbit.ledYBrightness|block\": \"LED أصفر %pin التبديل إلى $ledstate \",\n    \"Microbit.ledBBrightness|block\": \"LED أزرق %pin التبديل إلى $ledstate \",\n    \"Microbit.ledGBrightness|block\": \"LED أخضر %pin التبديل إلى $ledstate \",\n    \"Microbit.ledRBrightness|block\": \"LED أحمر %pin التبديل إلى $ledstate \"\n}\n","_locales/de/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"Sensor\",\n    \"{id:subcategory}Movement\": \"Bewegung\",\n    \"{id:subcategory}Audio-visual\": \"Ton und Licht\",\n    \"{id:group}RGB LED Module\": \"RGB LED Modul\",\n    \"{id:group}OLED Module\": \"OLED Display\",\n    \"{id:group}Laser Module\": \"Laser Modul\",\n    \"{id:group}Recording Module\": \"Aufnahme Modul\",\n    \"{id:group}Servo Motor\": \"Servomotor\",\n    \"Microbit.rock.orient1|block\": \"Oben\",\n    \"Microbit.rock.orient2|block\": \"Unten\",\n    \"Microbit.rock.orient3|block\": \"Links\",\n    \"Microbit.rock.orient4|block\": \"Rechts\",\n    \"PingUnit.Centimeters|block\": \"Zentimeter\",\n    \"PingUnit.MicroSeconds|block\": \"Mikrosekunden\",\n    \"PingUnit.Inches|block\": \"Zoll\",\n    \"Microbit.buttonState|block\": \"Tastensensor %buttonpin\",\n    \"Microbit.hState|block\": \"Hallsensor %hallpin\",\n    \"Microbit.farState|block\": \"Fernsensor %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"Potentiometer %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"Grausensor %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"Lichtsensor %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"Flammsensor %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"Wassersensor %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"Brenngassensor %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"Bodensensor %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"Wassertemperatursensor %waterproofpin\",\n    \"Microbit.ping|block\": \"Ultraschallsensor %ultpins Einheit %unit\",\n    \"Microbit.pinpullup|block\": \"Linienfolgesensor %pin\",\n    \"Microbit.rocker|block\": \"Joystick %direction Richtung\",\n    \"Microbit.rockerori|block\": \"Joystick erkannt %orientation\",\n    \"Microbit.pir|block\": \"PIR-Sensor %pirpin Bewegung erkannt\",\n    \"Microbit.ReadWaterLevel|block\": \"Wassersensor %waterlevelpin\",\n    \"Microbit.enMotorcolor.red|block\": \"Rot\",\n    \"Microbit.enMotorcolor.blue|block\": \"Grün\",\n    \"Microbit.enMotorcolor.green|block\": \"Blau\",\n    \"Microbit.enMotorcolor.yellow|block\": \"Gelb\",\n    \"Microbit.Servo4|block\": \"Servomotor| %num| Winkel %value\",\n    \"Microbit.MotorRun|block\": \"Motor|%index| Geschwindigkeit(-255~255) %speed\",\n    \"Microbit.motorFan|block\": \"Ventilator %fanpin Schalter zu $fanstate || Geschwindigkeit %speed\",\n    \"Microbit.elecmagnet|block\": \"Elektromagnet %elecpin Schalter zu %magState || Magnetkraft %force\",\n    \"Microbit.runMotor|block\": \"|%motoraddress| Motor mit Geschwindigkeit |%speed| drehen\",\n    \"Microbit.runMotor|group\": \"Servomotor\",\n    \"Microbit.Writemotorlocation|block\": \"|%motoraddress| Motor mit Geschwindigkeit |%speed| auf Position |%location| bewegen\",\n    \"Microbit.Writemotorrelativelocation|block\": \"|%motoraddress| Motor mit Geschwindigkeit |%speed| um |%location| Grad drehen\",\n    \"Microbit.Writemotorrelativetime|block\": \"|%motoraddress| Motor mit Geschwindigkeit |%speed| für |%time| Sekunden drehen\",\n    \"Microbit.runDMotor|block\": \"Doppelmotor mit %speed1 %speed2 Geschwindigkeit drehen\",\n    \"Microbit.WriteDmotorlocation|block\": \"Doppelmotor mit %speed1 %speed2 Geschwindigkeit um %location Grad drehen\",\n    \"Microbit.DMotor|block\": \"Linker Motor gesetzt auf |%motoraddress1| Rechter Motor gesetzt auf |%motoraddress2|\",\n    \"Microbit.Readmotorspeed|block\": \"Geschwindigkeit des Motors |%motoraddress| lesen\",\n    \"Microbit.Readmotorlocation|block\": \"Position des Motors |%motoraddress| lesen\",\n    \"Microbit.writeDmotortime|block\": \"Doppelmotor mit %speed1 %speed2 Geschwindigkeit für %time Sekunden drehen\",\n    \"Record_list.rl1|block\": \"Maschinengewehr Schuss\",\n    \"Record_list.rl2|block\": \"Laserabfeuerung\",\n    \"Record_list.rl3|block\": \"Rennwagen Beschleunigung\",\n    \"Record_list.rl4|block\": \"Krieg beginnt\",\n    \"Record_list.rl5|block\": \"Countdown\",\n    \"Record_list.rl6|block\": \"Aufnahme\",\n    \"Microbit.Record_id|block\": \"Aufnahme Modul - Abspielen %recordID\",\n    \"Microbit.laserController|block\": \"Laser %laserpin Schalter zu %laserState || Laser %intensity\",\n    \"Microbit.showString|block\": \"Zeige Text an  Bitte Position wählen %oled|Text %s\",\n    \"Microbit.showNumber|block\": \"Zeige Zahl an  Bitte Position wählen %oled|Zahl %num\",\n    \"Microbit.showStringxy|block\": \"Zeige Text an bei x %x|y %y| Text %s| Farbe %color\",\n    \"Microbit.showNumberxy|block\": \"Zeige Zahl an bei x %x|y %y| Zahl %num| Farbe %color\",\n    \"Microbit.clear|block\": \"Löschen\",\n    \"Microbit.init|block\": \"OLED initialisieren\",\n    \"NeoPixelColors.Red|block\": \"Rot\",\n    \"NeoPixelColors.Orange|block\": \"Orange\",\n    \"NeoPixelColors.Yellow|block\": \"Gelb\",\n    \"NeoPixelColors.Green|block\": \"Grün\",\n    \"NeoPixelColors.Blue|block\": \"Blau\",\n    \"NeoPixelColors.Indigo|block\": \"Indigo\",\n    \"NeoPixelColors.Violet|block\": \"Violett\",\n    \"NeoPixelColors.Purple|block\": \"Lila\",\n    \"NeoPixelColors.White|block\": \"Weiß\",\n    \"NeoPixelColors.Black|block\": \"Schwarz\",\n    \"Microbit.Strip.showColor|block\": \"%strip|Zeige Farbe %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip|Zeige Regenbogen von %startHue|bis %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip|Setze Helligkeit %brightness\",\n    \"Microbit.create|block\": \"Lichtstreifen verwenden Port %neopixelpin\",\n    \"Microbit.rgb|block\": \"Rot %red|Grün %green|Blau %blue\",\n    \"Microbit.colors|block\": \"%color\",\n    \"Microbit.ledYBrightness|block\": \"Gelbe LED %pin Schalter zu $ledstate\",\n    \"Microbit.ledBBrightness|block\": \"Blaue LED %pin Schalter zu $ledstate\",\n    \"Microbit.ledGBrightness|block\": \"Grüne LED %pin Schalter zu $ledstate\",\n    \"Microbit.ledRBrightness|block\": \"Rote LED %pin Schalter zu $ledstate\"\n}\n","_locales/el/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"Αισθητήρας\",\n    \"{id:subcategory}Movement\": \"Κίνηση\",\n    \"{id:subcategory}Audio-visual\": \"Οπτικοακουστικά\",\n    \"{id:group}RGB LED Module\": \"RGB Φωτισμός\",\n    \"{id:group}OLED Module\": \"Οθόνη OLED\",\n    \"{id:group}Laser Module\": \"Μονάδα Λέιζερ\",\n    \"{id:group}Recording Module\": \"Μονάδα Καταγραφής\",\n    \"{id:group}Servo Motor\": \"Μοτέρ Σερβο\",\n    \"Microbit.rock.orient1|block\": \"Πάνω\",\n    \"Microbit.rock.orient2|block\": \"Κάτω\",\n    \"Microbit.rock.orient3|block\": \"Αριστερά\",\n    \"Microbit.rock.orient4|block\": \"Δεξιά\",\n    \"PingUnit.Centimeters|block\": \"Εκατοστά\",\n    \"PingUnit.MicroSeconds|block\": \"Μικροδευτερόλεπτα\",\n    \"PingUnit.Inches|block\": \"Ίντσες\",\n    \"Microbit.buttonState|block\": \"Αισθητήρας κουμπιού %buttonpin\",\n    \"Microbit.hState|block\": \"Αισθητήρας Χώρου %hallpin\",\n    \"Microbit.farState|block\": \"Αισθητήρας μακρινής απόστασης %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"Αναγνώστης Ποτενσιόμετρου %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"Αισθητήρας Γκρι Κλίμακας %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"Αισθητήρας Φωτεινότητας %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"Αισθητήρας Φλόγας %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"Αισθητήρας Επίπεδου Νερού %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"Αισθητήρας Συγκέντρωσης Καυσίμων Αερίων %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"Αισθητήρας Υγρασίας Εδάφους %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"Αδιάβροχος Αισθητήρας Θερμοκρασίας %waterproofpin\",\n    \"Microbit.ping|block\": \"Αισθητήρας Υπερήχων %ultpins Μονάδα %unit\",\n    \"Microbit.pinpullup|block\": \"Αισθητήρας Γραμμής %pin \",\n    \"Microbit.rocker|block\": \"Αισθητήρας Αντίκτυπου %direction Κατεύθυνση\",\n    \"Microbit.rockerori|block\": \"Ανίχνευση Αντίκτυπου %orientation \",\n    \"Microbit.pir|block\": \"Αισθητήρας Ανθρώπινης Κίνησης %pirpin Ανίχνευση Κίνησης\",\n    \"Microbit.ReadWaterLevel|block\": \"Αισθητήρας Επίπεδου Νερού %waterlevelpin\",\n    \"Microbit.enMotorcolor.red|block\": \"Κόκκινο\",\n    \"Microbit.enMotorcolor.blue|block\": \"Πράσινο\",\n    \"Microbit.enMotorcolor.green|block\": \"Μπλε\",\n    \"Microbit.enMotorcolor.yellow|block\": \"Κίτρινο\",\n    \"Microbit.Servo4|block\": \"Σερβοκινητήρας| %num|Γωνία %value\",\n    \"Microbit.MotorRun|block\": \"Μοτέρ|%index|Ταχύτητα(-255~255) %speed\",\n    \"Microbit.motorFan|block\": \"Ανεμιστήρας %fanpin Εναλλαγή σε $fanstate || Ταχύτητα %speed\",\n    \"Microbit.elecmagnet|block\": \"Ηλεκτρομαγνήτης %elecpin Εναλλαγή σε %magState || Μαγνητική Δύναμη %force\",\n    \"Microbit.runMotor|block\": \"|%motoraddress|Μοτέρ σε ταχύτητα|%speed|\",\n    \"Microbit.runMotor|group\": \"Σερβοκινητήρας\",\n    \"Microbit.Writemotorlocation|block\": \"|%motoraddress|Μοτέρ σε ταχύτητα|%speed|μετακίνηση στο σημείο|%location|\",\n    \"Microbit.Writemotorrelativelocation|block\": \"|%motoraddress|Μοτέρ σε ταχύτητα|%speed|μετακίνηση κατά %location| μοίρες\",\n    \"Microbit.Writemotorrelativetime|block\": \"|%motoraddress|Μοτέρ σε ταχύτητα|%speed|μετακίνηση για %time| δευτερόλεπτα\",\n    \"Microbit.runDMotor|block\": \"Διπλό μοτέρ σε ταχύτητες %speed1 %speed2\",\n    \"Microbit.WriteDmotorlocation|block\": \"Διπλό μοτέρ σε ταχύτητες %speed1 %speed2 σε γωνία %location\",\n    \"Microbit.DMotor|block\": \"Αριστερό μοτέρ ορισμένο σε %motoraddress1 Δεξιό μοτέρ ορισμένο σε %motoraddress2\",\n    \"Microbit.Readmotorspeed|block\": \"Ανάγνωση ταχύτητας μοτέρ %motoraddress \",\n    \"Microbit.Readmotorlocation|block\": \"Ανάγνωση θέσης μοτέρ %motoraddress\",\n    \"Microbit.writeDmotortime|block\": \"Διπλό μοτέρ σε ταχύτητες %speed1 %speed2 για %time δευτερόλεπτα\",\n    \"Record_list.rl1|block\": \"Σκανδάλη Μηχανής\",\n    \"Record_list.rl2|block\": \"Λέιζερ Εκπομπή\",\n    \"Record_list.rl3|block\": \"Ταχύτητα Αγωνιστικού Αυτοκινήτου\",\n    \"Record_list.rl4|block\": \"Πόλεμος Ξεκινά\",\n    \"Record_list.rl5|block\": \"Αντίστροφη Μέτρηση\",\n    \"Record_list.rl6|block\": \"Ηχογράφηση\",\n    \"Microbit.Record_id|block\": \"Μονάδα Καταγραφής - Αναπαραγωγή %recordID\",\n    \"Microbit.laserController|block\": \"Λέιζερ %laserpin Εναλλαγή σε %laserState || Λέιζερ %intensity\",\n    \"Microbit.showString|block\": \"Εμφάνιση Κειμένου  Επιλέξτε Θέση Εμφάνισης %oled|Κείμενο %s\",\n    \"Microbit.showNumber|block\": \"Εμφάνιση Αριθμού Επιλέξτε Θέση Εμφάνισης %oled|Αριθμός %num\",\n    \"Microbit.showStringxy|block\": \"Εμφάνιση string στη θέση x %x|y %y|Κείμενο %s|Χρώμα %color\",\n    \"Microbit.showNumberxy|block\": \"Εμφάνιση Αριθμού στη θέση x %x|y %y|Αριθμός %num|Χρώμα %color\",\n    \"Microbit.clear|block\": \"Καθαρισμός\",\n    \"Microbit.init|block\": \"Αρχικοποίηση OLED\",\n    \"NeoPixelColors.Red|block\": \"Κόκκινο\",\n    \"NeoPixelColors.Orange|block\": \"Πορτοκαλί\",\n    \"NeoPixelColors.Yellow|block\": \"Κίτρινο\",\n    \"NeoPixelColors.Green|block\": \"Πράσινο\",\n    \"NeoPixelColors.Blue|block\": \"Μπλε\",\n    \"NeoPixelColors.Indigo|block\": \"Ίντιγκο\",\n    \"NeoPixelColors.Violet|block\": \"Βιολέτα\",\n    \"NeoPixelColors.Purple|block\": \"Μωβ\",\n    \"NeoPixelColors.White|block\": \"Λευκό\",\n    \"NeoPixelColors.Black|block\": \"Μαύρο\",\n    \"Microbit.Strip.showColor|block\": \"%strip|Εμφάνιση Χρώματος %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip|Εμφάνιση Ουράνιου Τόξου από %startHue|ως %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip|Ρύθμιση Φωτεινότητας %brightness\",\n    \"Microbit.create|block\": \"Ροδέλα Χρησιμοποιεί Θύρα %neopixelpin \",\n    \"Microbit.rgb|block\": \"Κόκκινο %red|Πράσινο %green|Μπλε %blue\",\n    \"Microbit.colors|block\": \"%color\",\n    \"Microbit.ledYBrightness|block\": \"Κίτρινο LED %pin Εναλλαγή σε $ledstate \",\n    \"Microbit.ledBBrightness|block\": \"Μπλε LED %pin Εναλλαγή σε $ledstate \",\n    \"Microbit.ledGBrightness|block\": \"Πράσινο LED %pin Εναλλαγή σε $ledstate \",\n    \"Microbit.ledRBrightness|block\": \"Κόκκινο LED %pin Εναλλαγή σε $ledstate \"\n}\n","_locales/fr/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"Capteur\",\n    \"{id:subcategory}Movement\": \"Mouvement\",\n    \"{id:subcategory}Audio-visual\": \"Audiovisuel\",\n    \"{id:group}RGB LED Module\": \"LED RGB\",\n    \"{id:group}OLED Module\": \"Écran OLED\",\n    \"{id:group}Laser Module\": \"Module laser\",\n    \"{id:group}Recording Module\": \"Module d'enregistrement\",\n    \"{id:group}Servo Motor\": \"Servomoteur\",\n    \"Microbit.rock.orient1|block\": \"Haut\",\n    \"Microbit.rock.orient2|block\": \"Bas\",\n    \"Microbit.rock.orient3|block\": \"Gauche\",\n    \"Microbit.rock.orient4|block\": \"Droite\",\n    \"PingUnit.Centimeters|block\": \"Centimètres\",\n    \"PingUnit.MicroSeconds|block\": \"Microsecondes\",\n    \"PingUnit.Inches|block\": \"Pouces\",\n    \"Microbit.buttonState|block\": \"Capteur de bouton %buttonpin\",\n    \"Microbit.hState|block\": \"Capteur Hall %hallpin\",\n    \"Microbit.farState|block\": \"Capteur photoélectrique longue portée %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"Potentiomètre %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"Capteur de niveau de gris %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"Capteur de lumière %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"Capteur de flamme %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"Capteur de niveau d'eau %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"Capteur de gaz inflammable %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"Capteur d'humidité du sol %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"Capteur de température étanche %waterproofpin\",\n    \"Microbit.ping|block\": \"Capteur ultrasonique %ultpins unité %unit\",\n    \"Microbit.pinpullup|block\": \"Capteur de suivi de ligne %pin \",\n    \"Microbit.rocker|block\": \"Joystick %direction direction\",\n    \"Microbit.rockerori|block\": \"Joystick détecté %orientation \",\n    \"Microbit.pir|block\": \"Capteur infrarouge humain %pirpin détecte un mouvement\",\n    \"Microbit.ReadWaterLevel|block\": \"Capteur de niveau d'eau %waterlevelpin\",\n    \"Microbit.enMotorcolor.red|block\": \"Rouge\",\n    \"Microbit.enMotorcolor.blue|block\": \"Vert\",\n    \"Microbit.enMotorcolor.green|block\": \"Bleu\",\n    \"Microbit.enMotorcolor.yellow|block\": \"Jaune\",\n    \"Microbit.Servo4|block\": \"Servo| %num|angle %value\",\n    \"Microbit.MotorRun|block\": \"Moteur|%index|vitesse (-255~255) %speed\",\n    \"Microbit.motorFan|block\": \"Ventilateur %fanpin bascule à $fanstate || vitesse %speed\",\n    \"Microbit.elecmagnet|block\": \"Électroaimant %elecpin bascule à %magState || force %force\",\n    \"Microbit.runMotor|block\": \"|%motoraddress|moteur tourne à|%speed|vitesse\",\n    \"Microbit.runMotor|group\": \"Servomoteur\",\n    \"Microbit.Writemotorlocation|block\": \"|%motoraddress|moteur tourne à|%speed|vitesse vers|%location|\",\n    \"Microbit.Writemotorrelativelocation|block\": \"|%motoraddress|moteur tourne à|%speed|vitesse de|%location|degrés\",\n    \"Microbit.Writemotorrelativetime|block\": \"|%motoraddress|moteur tourne à|%speed|vitesse pendant|%time|secondes\",\n    \"Microbit.runDMotor|block\": \"Double moteur tourne à vitesse %speed1 %speed2\",\n    \"Microbit.WriteDmotorlocation|block\": \"Double moteur tourne à vitesse %speed1 %speed2 vers %location degrés\",\n    \"Microbit.DMotor|block\": \"Moteur gauche à|%motoraddress1|Moteur droit à|%motoraddress2|\",\n    \"Microbit.Readmotorspeed|block\": \"Lire la vitesse du moteur |%motoraddress|\",\n    \"Microbit.Readmotorlocation|block\": \"Lire la position du moteur |%motoraddress|\",\n    \"Microbit.writeDmotortime|block\": \"Double moteur tourne à vitesse %speed1 %speed2 pendant %time secondes\",\n    \"Record_list.rl1|block\": \"Rafale de mitraillette\",\n    \"Record_list.rl2|block\": \"Tir laser\",\n    \"Record_list.rl3|block\": \"Accélération de voiture\",\n    \"Record_list.rl4|block\": \"Début de la guerre\",\n    \"Record_list.rl5|block\": \"Compte à rebours\",\n    \"Record_list.rl6|block\": \"Enregistrement\",\n    \"Microbit.Record_id|block\": \"Module d'enregistrement - Lecture %recordID \",\n    \"Microbit.laserController|block\": \"Laser %laserpin bascule à %laserState || Intensité du laser %intensity\",\n    \"Microbit.showString|block\": \"Afficher texte à %oled|Texte %s\",\n    \"Microbit.showNumber|block\": \"Afficher nombre à %oled|Nombre %num\",\n    \"Microbit.showStringxy|block\": \"Afficher string à x %x|y %y|Texte %s|Couleur %color\",\n    \"Microbit.showNumberxy|block\": \"Afficher nombre à x %x|y %y|Nombre %num|Couleur %color\",\n    \"Microbit.clear|block\": \"Effacer\",\n    \"Microbit.init|block\": \"Initialiser OLED \",\n    \"NeoPixelColors.Red|block\": \"Rouge\",\n    \"NeoPixelColors.Orange|block\": \"Orange\",\n    \"NeoPixelColors.Yellow|block\": \"Jaune\",\n    \"NeoPixelColors.Green|block\": \"Vert\",\n    \"NeoPixelColors.Blue|block\": \"Bleu\",\n    \"NeoPixelColors.Indigo|block\": \"Indigo\",\n    \"NeoPixelColors.Violet|block\": \"Violet\",\n    \"NeoPixelColors.Purple|block\": \"Pourpre\",\n    \"NeoPixelColors.White|block\": \"Blanc\",\n    \"NeoPixelColors.Black|block\": \"Noir\",\n    \"Microbit.Strip.showColor|block\": \"%strip|Afficher couleur %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip|Afficher arc-en-ciel de %startHue|à %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip|Régler luminosité %brightness\",\n    \"Microbit.create|block\": \"Anneau de LED sur port %neopixelpin \",\n    \"Microbit.rgb|block\": \"Rouge %red|Vert %green|Bleu %blue\",\n    \"Microbit.colors|block\": \"%color\",\n    \"Microbit.ledYBrightness|block\": \"LED jaune %pin bascule à $ledstate \",\n    \"Microbit.ledBBrightness|block\": \"LED bleue %pin bascule à $ledstate \",\n    \"Microbit.ledGBrightness|block\": \"LED verte %pin bascule à $ledstate \",\n    \"Microbit.ledRBrightness|block\": \"LED rouge %pin bascule à $ledstate \"\n}\n","_locales/ja/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"センサー\",\n    \"{id:subcategory}Movement\": \"動作\",\n    \"{id:subcategory}Audio-visual\": \"音と光\",\n    \"{id:group}RGB LED Module\": \"RGB LED\",\n    \"{id:group}OLED Module\": \"OLEDディスプレイ\",\n    \"{id:group}Laser Module\": \"レーザーモジュール\",\n    \"{id:group}Recording Module\": \"録音モジュール\",\n    \"{id:group}Servo Motor\": \"サーボモーター\",\n    \"Microbit.rock.orient1|block\": \"上\",\n    \"Microbit.rock.orient2|block\": \"下\",\n    \"Microbit.rock.orient3|block\": \"左\",\n    \"Microbit.rock.orient4|block\": \"右\",\n    \"PingUnit.Centimeters|block\": \"センチメートル\",\n    \"PingUnit.MicroSeconds|block\": \"マイクロ秒\",\n    \"PingUnit.Inches|block\": \"インチ\",\n    \"Microbit.buttonState|block\": \"ボタンセンサー %buttonpin\",\n    \"Microbit.hState|block\": \"ホールセンサー %hallpin\",\n    \"Microbit.farState|block\": \"長距離光電式センサー %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"ポテンショメーター %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"グレースケールセンサー %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"光センサー %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"炎センサー %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"水位センサー %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"可燃性ガスセンサー %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"土壌湿度センサー %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"防水温度センサー %waterproofpin\",\n    \"Microbit.ping|block\": \"超音波センサー %ultpins 単位 %unit\",\n    \"Microbit.pinpullup|block\": \"ライントレースセンサー %pin \",\n    \"Microbit.rocker|block\": \"ジョイスティック %direction 方向\",\n    \"Microbit.rockerori|block\": \"ジョイスティックが %orientation を検出\",\n    \"Microbit.pir|block\": \"PIRセンサー %pirpin 動きを検出\",\n    \"Microbit.ReadWaterLevel|block\": \"水位センサー %waterlevelpin\",\n    \"Microbit.enMotorcolor.red|block\": \"赤\",\n    \"Microbit.enMotorcolor.blue|block\": \"青\",\n    \"Microbit.enMotorcolor.green|block\": \"緑\",\n    \"Microbit.enMotorcolor.yellow|block\": \"黄\",\n    \"Microbit.Servo4|block\": \"サーボ| %num|角度 %value\",\n    \"Microbit.MotorRun|block\": \"モーター|%index|速度(-255~255) %speed\",\n    \"Microbit.motorFan|block\": \"ファン %fanpin 切り替え %fanstate || 速度 %speed\",\n    \"Microbit.elecmagnet|block\": \"電磁石 %elecpin 切り替え %magState || 磁力 %force\",\n    \"Microbit.runMotor|block\": \"|%motoraddress|モーターを|%speed|速度で回転\",\n    \"Microbit.runMotor|group\": \"サーボモーター\",\n    \"Microbit.Writemotorlocation|block\": \"|%motoraddress|モーターを|%speed|速度で|%location|の位置へ移動\",\n    \"Microbit.Writemotorrelativelocation|block\": \"|%motoraddress|モーターを|%speed|速度で|%location|度回転\",\n    \"Microbit.Writemotorrelativetime|block\": \"|%motoraddress|モーターを|%speed|速度で|%time|秒間回転\",\n    \"Microbit.runDMotor|block\": \"デュアルモーター速度 %speed1 %speed2\",\n    \"Microbit.WriteDmotorlocation|block\": \"デュアルモーター速度 %speed1 %speed2 で %location 度回転\",\n    \"Microbit.DMotor|block\": \"左モーター|%motoraddress1|右モーター|%motoraddress2|設定\",\n    \"Microbit.Readmotorspeed|block\": \"|%motoraddress|モーターの速度を取得\",\n    \"Microbit.Readmotorlocation|block\": \"|%motoraddress|モーターの位置を取得\",\n    \"Microbit.writeDmotortime|block\": \"デュアルモーター速度 %speed1 %speed2 で %time 秒回転\",\n    \"Record_list.rl1|block\": \"マシンガン連射\",\n    \"Record_list.rl2|block\": \"レーザー発射\",\n    \"Record_list.rl3|block\": \"レーシング加速\",\n    \"Record_list.rl4|block\": \"戦闘開始\",\n    \"Record_list.rl5|block\": \"カウントダウン\",\n    \"Record_list.rl6|block\": \"録音\",\n    \"Microbit.Record_id|block\": \"録音モジュール-再生 %recordID \",\n    \"Microbit.laserController|block\": \"レーザー %laserpin 切り替え %laserState || 強度 %intensity\",\n    \"Microbit.showString|block\": \"表示 テキスト 位置を選択 %oled|テキスト %s\",\n    \"Microbit.showNumber|block\": \"表示 数字 位置を選択 %oled|数字 %num\",\n    \"Microbit.showStringxy|block\": \"表示 文字 x %x|y %y|テキスト %s|色 %color\",\n    \"Microbit.showNumberxy|block\": \"表示 数字 x %x|y %y|数字 %num|色 %color\",\n    \"Microbit.clear|block\": \"クリア\",\n    \"Microbit.init|block\": \"OLED 初期化\",\n    \"NeoPixelColors.Red|block\": \"赤\",\n    \"NeoPixelColors.Orange|block\": \"オレンジ\",\n    \"NeoPixelColors.Yellow|block\": \"黄\",\n    \"NeoPixelColors.Green|block\": \"緑\",\n    \"NeoPixelColors.Blue|block\": \"青\",\n    \"NeoPixelColors.Indigo|block\": \"藍色\",\n    \"NeoPixelColors.Violet|block\": \"バイオレット\",\n    \"NeoPixelColors.Purple|block\": \"紫\",\n    \"NeoPixelColors.White|block\": \"白\",\n    \"NeoPixelColors.Black|block\": \"黒\",\n    \"Microbit.Strip.showColor|block\": \"%strip|色を表示 %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip|虹を表示 開始 %startHue|終了 %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip|明るさを設定 %brightness\",\n    \"Microbit.create|block\": \"LEDリング ポート %neopixelpin \",\n    \"Microbit.rgb|block\": \"赤 %red|緑 %green|青 %blue\",\n    \"Microbit.colors|block\": \"%color\",\n    \"Microbit.ledYBrightness|block\": \"黄色 LED %pin 切り替え $ledstate\",\n    \"Microbit.ledBBrightness|block\": \"青色 LED %pin 切り替え $ledstate\",\n    \"Microbit.ledGBrightness|block\": \"緑色 LED %pin 切り替え $ledstate\",\n    \"Microbit.ledRBrightness|block\": \"赤色 LED %pin 切り替え $ledstate\"\n}\n","_locales/ko/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"센서\",\n    \"{id:subcategory}Movement\": \"동작\",\n    \"{id:subcategory}Audio-visual\": \"음향 및 조명\",\n    \"{id:group}RGB LED Module\": \"RGB LED 모듈\",\n    \"{id:group}OLED Module\": \"OLED 디스플레이\",\n    \"{id:group}Laser Module\": \"레이저 모듈\",\n    \"{id:group}Recording Module\": \"녹음 모듈\",\n    \"{id:group}Servo Motor\": \"서보 모터\",\n    \"Microbit.rock.orient1|block\": \"위\",\n    \"Microbit.rock.orient2|block\": \"아래\",\n    \"Microbit.rock.orient3|block\": \"왼쪽\",\n    \"Microbit.rock.orient4|block\": \"오른쪽\",\n    \"PingUnit.Centimeters|block\": \"센티미터\",\n    \"PingUnit.MicroSeconds|block\": \"마이크로초\",\n    \"PingUnit.Inches|block\": \"인치\",\n    \"Microbit.buttonState|block\": \"버튼 센서 %buttonpin\",\n    \"Microbit.hState|block\": \"홀 센서 %hallpin\",\n    \"Microbit.farState|block\": \"장거리 광전 센서 %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"가변저항기 %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"그레이 센서 %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"광 센서 %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"화염 센서 %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"수위 센서 %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"가연성 가스 센서 %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"토양 습도 센서 %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"방수 온도 센서 %waterproofpin\",\n    \"Microbit.ping|block\": \"초음파 센서 %ultpins 단위 %unit\",\n    \"Microbit.pinpullup|block\": \"라인 트래킹 센서 %pin \",\n    \"Microbit.rocker|block\": \"조이스틱 %direction 방향\",\n    \"Microbit.rockerori|block\": \"조이스틱 방향 %orientation 감지됨\",\n    \"Microbit.pir|block\": \"인체 적외선 센서 %pirpin 동작 감지됨\",\n    \"Microbit.ReadWaterLevel|block\": \"수위 센서 %waterlevelpin\",\n    \"Microbit.enMotorcolor.red|block\": \"빨강\",\n    \"Microbit.enMotorcolor.blue|block\": \"초록\",\n    \"Microbit.enMotorcolor.green|block\": \"파랑\",\n    \"Microbit.enMotorcolor.yellow|block\": \"노랑\",\n    \"Microbit.Servo4|block\": \"서보 모터| %num|각도 %value\",\n    \"Microbit.MotorRun|block\": \"모터|%index|속도(-255~255) %speed\",\n    \"Microbit.motorFan|block\": \"팬 %fanpin 상태 변경 $fanstate || 속도 %speed\",\n    \"Microbit.elecmagnet|block\": \"전자석 %elecpin 상태 변경 %magState || 자기력 %force\",\n    \"Microbit.runMotor|block\": \"|%motoraddress|모터가|%speed|속도로 회전\",\n    \"Microbit.runMotor|group\": \"서보 모터\",\n    \"Microbit.Writemotorlocation|block\": \"|%motoraddress|모터가|%speed|속도로|%location|위치로 이동\",\n    \"Microbit.Writemotorrelativelocation|block\": \"|%motoraddress|모터가|%speed|속도로|%location|도 회전\",\n    \"Microbit.Writemotorrelativetime|block\": \"|%motoraddress|모터가|%speed|속도로|%time|초 동안 회전\",\n    \"Microbit.runDMotor|block\": \"듀얼 모터가 %speed1 %speed2 속도로 회전\",\n    \"Microbit.WriteDmotorlocation|block\": \"듀얼 모터가 %speed1 %speed2 속도로 %location 도 회전\",\n    \"Microbit.DMotor|block\": \"왼쪽 모터 설정 |%motoraddress1|오른쪽 모터 설정 |%motoraddress2|\",\n    \"Microbit.Readmotorspeed|block\": \"|%motoraddress|모터 속도 읽기 \",\n    \"Microbit.Readmotorlocation|block\": \"|%motoraddress|모터 위치 읽기\",\n    \"Microbit.writeDmotortime|block\": \"듀얼 모터가 %speed1 %speed2 속도로 %time 초 동안 회전\",\n    \"Record_list.rl1|block\": \"기관총 사격\",\n    \"Record_list.rl2|block\": \"레이저 발사\",\n    \"Record_list.rl3|block\": \"레이싱카 가속\",\n    \"Record_list.rl4|block\": \"전쟁 시작\",\n    \"Record_list.rl5|block\": \"카운트다운\",\n    \"Record_list.rl6|block\": \"녹음\",\n    \"Microbit.Record_id|block\": \"녹음 모듈 - 재생 %recordID \",\n    \"Microbit.laserController|block\": \"레이저 %laserpin 상태 변경 %laserState || 레이저 강도 %intensity\",\n    \"Microbit.showString|block\": \"텍스트 표시 선택한 위치 %oled|텍스트 %s\",\n    \"Microbit.showNumber|block\": \"숫자 표시 선택한 위치 %oled|숫자 %num\",\n    \"Microbit.showStringxy|block\": \"문자열 표시 x %x|y %y|텍스트 %s|색상 %color\",\n    \"Microbit.showNumberxy|block\": \"숫자 표시 x %x|y %y|숫자 %num|색상 %color\",\n    \"Microbit.clear|block\": \"지우기\",\n    \"Microbit.init|block\": \"OLED 초기화\",\n    \"NeoPixelColors.Red|block\": \"빨강\",\n    \"NeoPixelColors.Orange|block\": \"주황\",\n    \"NeoPixelColors.Yellow|block\": \"노랑\",\n    \"NeoPixelColors.Green|block\": \"초록\",\n    \"NeoPixelColors.Blue|block\": \"파랑\",\n    \"NeoPixelColors.Indigo|block\": \"남색\",\n    \"NeoPixelColors.Violet|block\": \"보라\",\n    \"NeoPixelColors.Purple|block\": \"자주\",\n    \"NeoPixelColors.White|block\": \"흰색\",\n    \"NeoPixelColors.Black|block\": \"검정\",\n    \"Microbit.Strip.showColor|block\": \"%strip|색상 표시 %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip|무지개 표시 시작 %startHue|끝 %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip|밝기 설정 %brightness\",\n    \"Microbit.create|block\": \"LED 링 사용 포트 %neopixelpin\",\n    \"Microbit.rgb|block\": \"빨강 %red|초록 %green|파랑 %blue\",\n    \"Microbit.colors|block\": \"%color\",\n    \"Microbit.ledYBrightness|block\": \"노란색 LED %pin 상태 변경 $ledstate \",\n    \"Microbit.ledBBrightness|block\": \"파란색 LED %pin 상태 변경 $ledstate \",\n    \"Microbit.ledGBrightness|block\": \"초록색 LED %pin 상태 변경 $ledstate \",\n    \"Microbit.ledRBrightness|block\": \"빨간색 LED %pin 상태 변경 $ledstate \"\n}\n","_locales/ru/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"Датчики\",\n    \"{id:subcategory}Movement\": \"Движение\",\n    \"{id:subcategory}Audio-visual\": \"Исполнительные устройства\",\n    \"{id:group}RGB LED Module\": \"RGB-подсветка\",\n    \"{id:group}LED\": \"Светодиоды\",\n    \"{id:group}OLED Module\": \"OLED-дисплей\",\n    \"{id:group}Laser Module\": \"Лазерный модуль\",\n    \"{id:group}Recording Module\": \"Аудиомодуль\",\n    \"{id:group}Servo Motor\": \"Сервомотор\",\n    \"Microbit.rock.orient1|block\": \"вверх\",\n    \"Microbit.rock.orient2|block\": \"вниз\",\n    \"Microbit.rock.orient3|block\": \"влево\",\n    \"Microbit.rock.orient4|block\": \"вправо\",\n    \"PingUnit.Centimeters|block\": \"сантиметры\",\n    \"PingUnit.MicroSeconds|block\": \"микросекунды\",\n    \"PingUnit.Inches|block\": \"дюймы\",\n    \"Microbit.buttonState|block\": \"Кнопка %buttonpin\",\n    \"Microbit.hState|block\": \"Датчик Холла %hallpin\",\n    \"Microbit.farState|block\": \"Фотоэлектрический датчик %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"Потенциометр %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"Датчик оттенков серого %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"Датчик освещенности %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"Датчик пламени %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"Датчик уровня воды %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"Датчик горючих газов %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"Датчик влажности почвы %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"Датчик температуры %waterproofpin\",\n    \"Microbit.ping|block\": \"Ультразвуковой датчик %ultpins расстояние в %unit\",\n    \"Microbit.pinpullup|block\": \"Датчик следования по линии %pin\",\n    \"Microbit.rocker|block\": \"Джойстик %direction направление\",\n    \"Microbit.rockerori|block\": \"Обнаружено движение джойстика %orientation\",\n    \"Microbit.pir|block\": \"Инфракрасный датчик движения %pirpin обнаружил движение\",\n    \"Microbit.ReadWaterLevel|block\": \"Датчик уровня воды %waterlevelpin\",\n    \"Microbit.enMotorcolor.red|block\": \"красный\",\n    \"Microbit.enMotorcolor.blue|block\": \"зеленый\",\n    \"Microbit.enMotorcolor.green|block\": \"синий\",\n    \"Microbit.enMotorcolor.yellow|block\": \"желтый\",\n    \"Microbit.Servo4|block\": \"Задать сервоприводу| %num|угол %value\",\n    \"Microbit.MotorRun|block\": \"Задать скорость мотора|%index|в диапазоне(-255~255) значение%speed\",\n    \"Microbit.motorFan|block\": \"Модуль вентилятора %fanpin %fanstate || скорость %speed\",\n    \"Microbit.elecmagnet|block\": \"Электромагнит %elecpin %magState || сила %force\",\n    \"Microbit.runMotor|block\": \"|%motoraddress|мотор запустить со скоростью|%speed\",\n    \"Microbit.runMotor|group\": \"Сервопривод\",\n    \"Microbit.Writemotorlocation|block\": \"|%motoraddress|мотор запустить со скоростью|%speed|и перейти в положение|%location\",\n    \"Microbit.Writemotorrelativelocation|block\": \"|%motoraddress|мотор запустить со скоростью|%speed|на|%location|градусов\",\n    \"Microbit.Writemotorrelativetime|block\": \"|%motoraddress|мотор запустить со скоростью|%speed|на|%time|секунд\",\n    \"Microbit.runDMotor|block\": \"Запустить два мотора со скоростью %speed1 %speed2\",\n    \"Microbit.WriteDmotorlocation|block\": \"Запустить два мотора со скоростью %speed1 %speed2 на %location градусов\",\n    \"Microbit.DMotor|block\": \"Установить левый мотор как |%motoraddress1| установить правый мотор как |%motoraddress2|\",\n    \"Microbit.Readmotorspeed|block\": \"Определить скорость |%motoraddress мотора\",\n    \"Microbit.Readmotorlocation|block\": \"Определить положение |%motoraddress мотора\",\n    \"Microbit.writeDmotortime|block\": \"Запустить два мотора со скоростью %speed1 %speed2 на %time секунд\",\n    \"Record_list.rl1|block\": \"пулеметная очередь\",\n    \"Record_list.rl2|block\": \"лазерный выстрел\",\n    \"Record_list.rl3|block\": \"разгон машины\",\n    \"Record_list.rl4|block\": \"начало битвы\",\n    \"Record_list.rl5|block\": \"обратный отсчет\",\n    \"Record_list.rl6|block\": \"записанный звук\",\n    \"Microbit.Record_id|block\": \"Аудиомодуль - воспроизвести %recordID\",\n    \"Microbit.laserController|block\": \"Лазерный модуль %laserpin %laserState || интенсивность %intensity\",\n    \"Microbit.showString|block\": \"Отобразить текст – выберите позицию %oled|текст %s\",\n    \"Microbit.showNumber|block\": \"Отобразить число – выберите позицию %oled|число %num\",\n    \"Microbit.showStringxy|block\": \"Отобразить текст x %x|y %y|текст %s|цвет %color\",\n    \"Microbit.showNumberxy|block\": \"Отобразить число x %x|y %y|число %num|цвет %color\",\n    \"Microbit.clear|block\": \"Очистить\",\n    \"Microbit.init|block\": \"Включить OLED-дисплей\",\n    \"NeoPixelColors.Red|block\": \"красный\",\n    \"NeoPixelColors.Orange|block\": \"оранжевый\",\n    \"NeoPixelColors.Yellow|block\": \"жёлтый\",\n    \"NeoPixelColors.Green|block\": \"зелёный\",\n    \"NeoPixelColors.Blue|block\": \"синий\",\n    \"NeoPixelColors.Indigo|block\": \"индиго\",\n    \"NeoPixelColors.Violet|block\": \"фиолетовый\",\n    \"NeoPixelColors.Purple|block\": \"пурпурный\",\n    \"NeoPixelColors.White|block\": \"белый\",\n    \"NeoPixelColors.Black|block\": \"чёрный\",\n    \"Microbit.Strip.showColor|block\": \"%strip| отобразить цвет %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip| отобразить радугу от %startHue до %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip|установить яркость %brightness\",\n    \"Microbit.create|block\": \"светодиодное кольцо %neopixelpin\",\n    \"Microbit.rgb|block\": \"красный %red|зеленый %green|синий %blue\",\n    \"Microbit.colors|block\": \"%color\",\n    \"Microbit.ledYBrightness|block\": \"Желтый светодиод %pin %ledstate\",\n    \"Microbit.ledBBrightness|block\": \"Синий светодиод %pin %ledstate\",\n    \"Microbit.ledGBrightness|block\": \"Зеленый светодиод %pin %ledstate\",\n    \"Microbit.ledRBrightness|block\": \"Красный светодиод %pin %ledstate\"\n}\n","_locales/zh-TW/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"感測器\",\n    \"{id:subcategory}Movement\": \"動作\",\n    \"{id:subcategory}Audio-visual\": \"聲光\",\n    \"{id:group}RGB LED Module\": \"彩燈\",\n    \"{id:group}OLED Module\": \"OLED 顯示屏\",\n    \"{id:group}Laser Module\": \"激光模組\",\n    \"{id:group}Recording Module\": \"錄音模組\",\n    \"{id:group}Servo Motor\": \"伺服馬達\",\n    \"Microbit.rock.orient1|block\": \"上\",\n    \"Microbit.rock.orient2|block\": \"下\",\n    \"Microbit.rock.orient3|block\": \"左\",\n    \"Microbit.rock.orient4|block\": \"右\",\n    \"PingUnit.Centimeters|block\": \"厘米\",\n    \"PingUnit.MicroSeconds|block\": \"微秒\",\n    \"PingUnit.Inches|block\": \"英寸\",\n    \"Microbit.buttonState|block\": \"按鈕感測器 %buttonpin\",\n    \"Microbit.hState|block\": \"霍爾感測器 %hallpin\",\n    \"Microbit.farState|block\": \"遠距離光電感測器 %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"電位器 %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"灰度感測器 %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"光敏感測器 %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"火焰感測器 %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"水位感測器 %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"可燃氣體感測器 %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"土壤濕度感測器 %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"防水溫度感測器 %waterproofpin\",\n    \"Microbit.ping|block\": \"超聲波感測器 %ultpins 單位 %unit\",\n    \"Microbit.pinpullup|block\": \"巡線感測器 %pin \",\n    \"Microbit.rocker|block\": \"搖桿 %direction 方向\",\n    \"Microbit.rockerori|block\": \"檢測到搖桿 %orientation \",\n    \"Microbit.pir|block\": \"人體紅外感測器 %pirpin 檢測到運動\",\n    \"Microbit.ReadWaterLevel|block\": \"水位感測器 %waterlevelpin\",\n    \"Microbit.enMotorcolor.red|block\": \"紅\",\n    \"Microbit.enMotorcolor.blue|block\": \"綠\",\n    \"Microbit.enMotorcolor.green|block\": \"藍\",\n    \"Microbit.enMotorcolor.yellow|block\": \"黃\",\n    \"Microbit.Servo4|block\": \"舵機| %num|角度 %value\",\n    \"Microbit.MotorRun|block\": \"馬達|%index|速度(-255~255) %speed\",\n    \"Microbit.motorFan|block\": \"風扇 %fanpin 切換至 $fanstate || 速度 %speed\",\n    \"Microbit.elecmagnet|block\": \"電磁鐵 %elecpin 切換至 %magState || 磁力 %force\",\n    \"Microbit.runMotor|block\": \"|%motoraddress|馬達以|%speed|速度轉動\",\n    \"Microbit.runMotor|group\": \"伺服馬達\",\n    \"Microbit.Writemotorlocation|block\": \"|%motoraddress|馬達以|%speed|速度轉到|%location|的位置\",\n    \"Microbit.Writemotorrelativelocation|block\": \"|%motoraddress|馬達以|%speed|速度轉|%location|度\",\n    \"Microbit.Writemotorrelativetime|block\": \"|%motoraddress|馬達以|%speed|速度轉|%time|秒\",\n    \"Microbit.runDMotor|block\": \"雙馬達以%speed1 %speed2 速度轉動\",\n    \"Microbit.WriteDmotorlocation|block\": \"雙馬達以%speed1 %speed2 速度轉%location 度\",\n    \"Microbit.DMotor|block\": \"左馬達設置為|%motoraddress1|右馬達設置為|%motoraddress2|\",\n    \"Microbit.Readmotorspeed|block\": \"讀取|%motoraddress|馬達的速度 \",\n    \"Microbit.Readmotorlocation|block\": \"讀取|%motoraddress|馬達的位置\",\n    \"Microbit.writeDmotortime|block\": \"雙馬達以%speed1 %speed2 速度轉%time 秒\",\n    \"Record_list.rl1|block\": \"機槍掃射\",\n    \"Record_list.rl2|block\": \"激光發射\",\n    \"Record_list.rl3|block\": \"賽車加速\",\n    \"Record_list.rl4|block\": \"戰爭開始\",\n    \"Record_list.rl5|block\": \"倒計時\",\n    \"Record_list.rl6|block\": \"錄音\",\n    \"Microbit.Record_id|block\": \"錄音模組-播放 %recordID \",\n    \"Microbit.laserController|block\": \"激光 %laserpin 切換至 %laserState || 激光 %intensity\",\n    \"Microbit.showString|block\": \"顯示 文本 請選擇顯示位置%oled|文本 %s\",\n    \"Microbit.showNumber|block\": \"顯示 數字 請選擇顯示位置%oled|數字 %num\",\n    \"Microbit.showStringxy|block\": \"顯示 string 在 x %x|y %y|文本 %s|顏色 %color\",\n    \"Microbit.showNumberxy|block\": \"顯示 數字 在 x %x|y %y|數字 %num|顏色 %color\",\n    \"Microbit.clear|block\": \"清除\",\n    \"Microbit.init|block\": \"初始化 OLED \",\n    \"NeoPixelColors.Red|block\": \"紅\",\n    \"NeoPixelColors.Orange|block\": \"橙\",\n    \"NeoPixelColors.Yellow|block\": \"黃\",\n    \"NeoPixelColors.Green|block\": \"綠\",\n    \"NeoPixelColors.Blue|block\": \"藍\",\n    \"NeoPixelColors.Indigo|block\": \"靛藍\",\n    \"NeoPixelColors.Violet|block\": \"紫羅蘭\",\n    \"NeoPixelColors.Purple|block\": \"紫\",\n    \"NeoPixelColors.White|block\": \"白\",\n    \"NeoPixelColors.Black|block\": \"黑\",\n    \"Microbit.Strip.showColor|block\": \"%strip|顯示 顏色 %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip|顯示 彩虹 從 %startHue|到 %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip|設置 亮度 %brightness\",\n    \"Microbit.create|block\": \"燈環使用端口 %neopixelpin \",\n    \"Microbit.rgb|block\": \"紅 %red|綠 %green|藍 %blue\",\n    \"Microbit.colors|block\": \"%color\",\n    \"Microbit.ledYBrightness|block\": \"黃色 LED %pin 切換到 $ledstate \",\n    \"Microbit.ledBBrightness|block\": \"藍色 LED %pin 切換到 $ledstate \",\n    \"Microbit.ledGBrightness|block\": \"綠色 LED %pin 切換到 $ledstate \",\n    \"Microbit.ledRBrightness|block\": \"紅色 LED %pin 切換到 $ledstate \"\n}\n","_locales/zh/icreaterobot-strings.json":"{\n    \"{id:subcategory}Sensor\": \"传感器\",\n    \"{id:subcategory}Movement\": \"动作\",\n    \"{id:subcategory}Audio-visual\": \"声光\",\n    \"{id:group}RGB LED Module\": \"彩灯\",\n    \"{id:group}OLED Module\": \"OLED 显示屏\",\n    \"{id:group}Laser Module\": \"激光模块\",\n    \"{id:group}Recording Module\": \"录音模块\",\n    \"{id:group}Servo Motor\": \"伺服电机\",\n\n    \"Microbit.rock.orient1|block\": \"上\",\n    \"Microbit.rock.orient2|block\": \"下\",\n    \"Microbit.rock.orient3|block\": \"左\",\n    \"Microbit.rock.orient4|block\": \"右\",\n    \"PingUnit.Centimeters|block\": \"厘米\",\n    \"PingUnit.MicroSeconds|block\": \"微秒\",\n    \"PingUnit.Inches|block\": \"英寸\",\n    \"Microbit.buttonState|block\": \"按钮传感器 %buttonpin\",\n    \"Microbit.hState|block\": \"霍尔传感器 %hallpin\",\n    \"Microbit.farState|block\": \"远距离光电传感器 %farStatepin\",\n    \"Microbit.potentiometerRead|block\": \"电位器 %potentiometerpin\",\n    \"Microbit.ReadGrayLevel|block\": \"灰度传感器 %graylevelpin\",\n    \"Microbit.ReadLightIntensity|block\": \"光敏传感器 %lightintensitypin\",\n    \"Microbit.Readflame|block\": \"火焰传感器 %flamepin\",\n    \"Microbit.ReadflameReadWaterLevel|block\": \"水位传感器 %waterlevelpin\",\n    \"Microbit.ReadGasConcentration|block\": \"可燃气体传感器 %gasconcentrationpin\",\n    \"Microbit.ReadSoilHumidity|block\": \"土壤湿度传感器 %soilhumiditypin\",\n    \"Microbit.readWaterTemp|block\": \"防水温度传感器 %waterproofpin\",\n    \"Microbit.ping|block\": \"超声波传感器 %ultpins 单位 %unit\",\n    \"Microbit.pinpullup|block\": \"巡线传感器 %pin \",\n    \"Microbit.rocker|block\": \"摇杆 %direction 方向\",\n    \"Microbit.rockerori|block\": \"检测到摇杆 %orientation \",\n    \"Microbit.pir|block\": \"人体红外传感器 %pirpin 检测到运动\",\n    \"Microbit.ReadWaterLevel|block\": \"水位传感器 %waterlevelpin\",\n\n\n\n    \"Microbit.enMotorcolor.red|block\": \"红\",\n    \"Microbit.enMotorcolor.blue|block\": \"绿\",\n    \"Microbit.enMotorcolor.green|block\": \"蓝\",\n    \"Microbit.enMotorcolor.yellow|block\": \"黄\",\n    \"Microbit.Servo4|block\": \"舵机| %num|角度 %value\",\n    \"Microbit.MotorRun|block\": \"电机|%index|速度(-255~255) %speed\",\n    \"Microbit.motorFan|block\": \"风扇 %fanpin 切换至 $fanstate || 速度 %speed\",\n    \"Microbit.elecmagnet|block\": \"电磁铁 %elecpin 切换至 %magState || 磁力 %force\",\n    \"Microbit.runMotor|block\": \"|%motoraddress|电机以|%speed|速度转动\",\n    \"Microbit.runMotor|group\": \"伺服电机\",\n    \"Microbit.Writemotorlocation|block\": \"|%motoraddress|电机以|%speed|速度转到|%location|的位置\",\n    \"Microbit.Writemotorrelativelocation|block\": \"|%motoraddress|电机以|%speed|速度转|%location|度\",\n    \"Microbit.Writemotorrelativetime|block\": \"|%motoraddress|电机以|%speed|速度转|%time|秒\",\n    \"Microbit.runDMotor|block\": \"双电机以%speed1 %speed2 速度转动\",\n    \"Microbit.WriteDmotorlocation|block\": \"双电机以%speed1 %speed2 速度转%location 度\",\n    \"Microbit.DMotor|block\": \"左电机设置为|%motoraddress1|右电机设置为|%motoraddress2|\",\n    \"Microbit.Readmotorspeed|block\": \"读取|%motoraddress|电机的速度 \",\n    \"Microbit.Readmotorlocation|block\": \"读取|%motoraddress|电机的位置\",\n    \"Microbit.writeDmotortime|block\": \"双电机以%speed1 %speed2 速度转%time 秒\",\n\n\n\n\n    \"Record_list.rl1|block\": \"机枪扫射\",\n    \"Record_list.rl2|block\": \"激光发射\",\n    \"Record_list.rl3|block\": \"赛车加速\",\n    \"Record_list.rl4|block\": \"战争开始\",\n    \"Record_list.rl5|block\": \"倒计时\",\n    \"Record_list.rl6|block\": \"录音\",\n    \"Microbit.Record_id|block\": \"录音模块-播放 %recordID \",\n\n    \"Microbit.laserController|block\": \"激光 %laserpin 切换至 %laserState || 激光 %intensity\",\n\n    \"Microbit.showString|block\": \"显示 文本 请选择显示位置%oled|文本 %s\",\n    \"Microbit.showNumber|block\": \"显示 数字 请选择显示位置%oled|数字 %num\",\n    \"Microbit.showStringxy|block\": \"显示 string 在 x %x|y %y|文本 %s|颜色 %color\",\n    \"Microbit.showNumberxy|block\": \"显示 数字 在 x %x|y %y|数字 %num|颜色 %color\",\n    \"Microbit.clear|block\": \"清除\",\n    \"Microbit.init|block\": \"初始化 OLED \",\n\n    \"NeoPixelColors.Red|block\": \"红\",\n    \"NeoPixelColors.Orange|block\": \"橙\",\n    \"NeoPixelColors.Yellow|block\": \"黄\",\n    \"NeoPixelColors.Green|block\": \"绿\",\n    \"NeoPixelColors.Blue|block\": \"蓝\",\n    \"NeoPixelColors.Indigo|block\": \"靛蓝\",\n    \"NeoPixelColors.Violet|block\": \"紫罗兰\",\n    \"NeoPixelColors.Purple|block\": \"紫\",\n    \"NeoPixelColors.White|block\": \"白\",\n    \"NeoPixelColors.Black|block\": \"黑\",\n    \"Microbit.Strip.showColor|block\": \"%strip|显示 颜色 %rgb=neopixel_colors\",\n    \"Microbit.Strip.showRainbow|block\": \"%strip|显示 彩虹 从 %startHue|到 %endHue\",\n    \"Microbit.Strip.setBrightness|block\": \"%strip|设置 亮度 %brightness\",\n    \"Microbit.create|block\": \"灯环使用端口 %neopixelpin \",\n    \"Microbit.rgb|block\": \"红 %red|绿 %green|蓝 %blue\",\n    \"Microbit.colors|block\": \"%color\",\n\n    \"Microbit.ledYBrightness|block\": \"黄色 LED %pin 切换到 $ledstate \",\n    \"Microbit.ledBBrightness|block\": \"蓝色 LED %pin 切换到 $ledstate \",\n    \"Microbit.ledGBrightness|block\": \"绿色 LED %pin 切换到 $ledstate \",\n    \"Microbit.ledRBrightness|block\": \"红色 LED %pin 切换到 $ledstate \"\n}\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n    /**\n     * Andy England @ SparkFun Electronics\n     * June 4, 2019\n     * https://github.com/sparkfun/pxt-gator-particle\n     *\n     * Development environment specifics:\n     * Written in Microsoft PXT\n     * Tested with a SparkFun Gator:Particle Sensor\n     *\n     * This code is released under the [MIT License](http://opensource.org/licenses/MIT).\n     * Please review the LICENSE.md file included with this example. If you have any questions\n     * or concerns with licensing, please contact techsupport@sparkfun.com.\n     * Distributed as-is; no warranty is given.\n     */\n\n    declare const enum LEDToRead {\n    //% block=\"红光\" enumval=1\n    Red = 1,\n    //% block=\"红外线\" enumval=2\n    Infrared = 2,\n    }\n\n\n    declare const enum HeartbeatType {\n    //% block=\"瞬时心率\" enumval=0\n    BPM = 0,\n    //% block=\"平均心率\" enumval=1\n    AVG = 1,\n    }\n\n\n    declare const enum LEDMode {\n    //% block=\"Red\" enumval=2\n    RedLED = 2,\n    //% block=\"Red & Infrared\" enumval=3\n    RedAndIR = 3,\n    }\n\n// Auto-generated. Do not edit. Really.\n","heart.cpp":"/**\n* Andy England @ SparkFun Electronics\n* June 4, 2019\n* https://github.com/sparkfun/pxt-gator-particle\n*\n* Development environment specifics:\n* Written in Microsoft PXT\n* Tested with a SparkFun Gator:Particle Sensor\n*\n* This code is released under the [MIT License](http://opensource.org/licenses/MIT).\n* Please review the LICENSE.md file included with this example. If you have any questions\n* or concerns with licensing, please contact techsupport@sparkfun.com.\n* Distributed as-is; no warranty is given.\n*/\n\n\n#include \"pxt.h\"\n#include <cstdint>\n#include <math.h>\n#include \"MAX30105.h\"\n\nenum LEDToRead{\n\t//% block=\"红光\" enumval=1\n\tRed=1,\t\n\t//% block=\"红外线\" enumval=2\n\tInfrared=2,\n};\n \nenum HeartbeatType{\n\t//% block=\"瞬时心率\" enumval=0\n\tBPM=0,\n\t//% block=\"平均心率\" enumval=1\n\tAVG=1,\n};\n\nenum LEDMode{\n\t//% block=\"Red\" enumval=2\n\tRedLED=2,\n\t//% block=\"Red & Infrared\" enumval=3\n\tRedAndIR=3,\n};\n\nusing namespace pxt;\n\nnamespace Microbit {\n\tMAX30105 *particleSensor;\n\tconst uint8_t RATE_SIZE = 4; //Increase this for more averaging. 4 is good.\n\tuint8_t rates[RATE_SIZE]; //Array of heart rates\n\tuint8_t rateSpot = 0;\n\tunsigned long lastBeat = 0; //Time at which the last beat occurred\n\t\n\tfloat beatsPerMinute;\n\tint beatAvg;\n\n\t//%\n\tvoid begin()\n\t{\n\t\tparticleSensor->beginParticle();\n\t\tparticleSensor->setup(0x1F, 4, 2, 400, 411, 4096);\n\t}\n\t\n\t//%\n\tuint32_t color(uint8_t type)\n\t{\n\t\tuint32_t colorValue;\n\t\tswitch(type)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\tcolorValue = particleSensor->getRed();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcolorValue = particleSensor->getIR();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn colorValue;\n\t}\n\n\t//%\n\tvoid setReadMode(uint8_t mode)\n\t{\n\t\tparticleSensor->setLEDMode(mode);\n\t}\n\n\t//%\n\tvoid setAmplitude(uint8_t led, uint8_t myBrightness)\n\t{\n\t\tswitch(led)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\tparticleSensor->setPulseAmplitudeRed(myBrightness);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparticleSensor->setPulseAmplitudeIR(myBrightness);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//%\n\tint16_t heartbeat(uint8_t type)\n\t{\n\t\tuint8_t myBeat;\n\t\tparticleSensor->safeCheck(100);\n\t\tdo\n\t\t{\n\t\t\tuint32_t irValue = particleSensor->getFIFOIR();\n\t\t\tif (particleSensor->checkForBeat(irValue) == true)\n\t\t\t{\n\t\t\t\t//We sensed a beat!\n\t\t\t\tunsigned long delta = uBit.systemTime() - lastBeat;\n\t\t\t\tlastBeat = uBit.systemTime();\n\n\t\t\t\tbeatsPerMinute = 60 / (delta / 1000.0);\n\n\t\t\t\tif (beatsPerMinute < 255 && beatsPerMinute > 20)\n\t\t\t\t{\n\t\t\t\t\trates[rateSpot++] = (uint8_t)beatsPerMinute; //Store this reading in the array\n\t\t\t\t\trateSpot %= RATE_SIZE; //Wrap variable\n\n\t\t\t\t\t//Take average of readings\n\t\t\t\t\tbeatAvg = 0;\n\t\t\t\t\tfor (uint8_t x = 0 ; x < RATE_SIZE ; x++){\n\t\t\t\t\t\tbeatAvg += rates[x];\n\t\t\t\t\t}\n\t\t\t\t\tbeatAvg /= RATE_SIZE;\n\t\t\t\t}\n\t\t\t}\n\t\t} while(particleSensor->nextSample());\n\t\tswitch(type)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tmyBeat = (uint8_t)beatsPerMinute;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tmyBeat = (uint8_t)beatAvg;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t}\n\t\treturn myBeat;\n\t}\n}\n","main.ts":"enum Oled {\n\n    //% block=\" \"\n\n    oled1 = 0,\n\n    //% block=\" \"\n\n    oled2 = 1,\n\n    //% block=\" \"\n\n    oled3 = 2,\n\n    //% block=\" \"\n\n    oled4 = 3,\n\n    //% block=\" \"\n\n    oled5 = 4,\n\n    //% block=\" \"\n\n    oled6 = 5,\n\n    //% block=\" \"\n\n    oled7 = 6,\n\n    //% block=\" \"\n\n    oled8 = 7,\n\n    //% block=\" \"\n\n    oled9 = 8,\n\n    //% block=\" \"\n\n    oled10 = 9,\n\n    //% block=\" \"\n\n    oled11 = 10,\n\n    //% block=\" \"\n\n    oled12 = 11,\n\n    //% block=\" \"\n\n    oled13 = 12,\n\n    //% block=\" \"\n\n    oled14 = 13,\n\n    //% block=\" \"\n\n    oled15 = 14,\n\n    //% block=\" \"\n\n    oled16 = 15,\n\n    //% block=\" \"\n\n    oled17 = 16,\n\n    //% block=\" \"\n\n    oled18 = 17,\n\n    //% block=\" \"\n\n    oled19 = 18,\n\n    //% block=\" \"\n\n    oled20 = 19,\n\n    //% block=\" \"\n\n    oled21 = 20,\n\n    //% block=\" \"\n\n    oled22 = 21,\n\n    //% block=\" \"\n\n    oled23 = 22,\n\n    //% block=\" \"\n\n    oled24 = 23,\n\n    //% block=\" \"\n\n    oled25 = 24,\n\n    //% block=\" \"\n\n    oled26 = 25,\n\n    //% block=\" \"\n\n    oled27 = 26,\n\n    //% block=\" \"\n\n    oled28 = 27,\n\n    //% block=\" \"\n\n    oled29 = 28,\n\n    //% block=\" \"\n\n    oled30 = 29,\n\n    //% block=\" \"\n\n    oled31 = 30,\n\n    //% block=\" \"\n\n    oled32 = 31,\n\n    //% block=\" \"\n\n    oled33 = 32,\n\n    //% block=\" \"\n\n    oled34 = 33,\n\n    //% block=\" \"\n\n    oled35 = 34,\n\n    //% block=\" \"\n\n    oled36 = 35,\n\n    //% block=\" \"\n\n    oled37 = 36,\n\n    //% block=\" \"\n\n    oled38 = 37,\n\n    //% block=\" \"\n\n    oled39 = 38,\n\n    //% block=\" \"\n\n    oled40 = 39,\n\n    //% block=\" \"\n\n    oled41 = 40,\n\n    //% block=\" \"\n\n    oled42 = 41,\n\n    //% block=\" \"\n\n    oled43 = 42,\n\n    //% block=\" \"\n\n    oled44 = 43,\n\n    //% block=\" \"\n\n    oled45 = 44,\n\n    //% block=\" \"\n\n    oled46 = 45,\n\n    //% block=\" \"\n\n    oled47 = 46,\n\n    //% block=\" \"\n\n    oled48 = 47,\n\n    //% block=\" \"\n\n    oled49 = 48,\n\n    //% block=\" \"\n\n    oled50 = 49,\n\n    //% block=\" \"\n\n    oled51 = 50,\n\n    //% block=\" \"\n\n    oled52 = 51,\n\n\n\n\n\n}\nenum Write_pin {\n\n    //% block=\"P0\"\n\n    w0 = 1,\n\n    //% block=\"P16\"\n\n    w1 = 2,\n\n    //% block=\"P1\"\n\n    w2 = 3,\n\n    //% block=\"P12\"\n\n    w3 = 4,\n\n    //% block=\"P2\"\n\n    w4 = 5,\n\n    //% block=\"P8\"\n\n    w5 = 6\n\n\n\n}\nenum Read_pin {\n\n    //% block=\"P0\"\n\n    r0 = 1,\n\n    //% block=\"P1\"\n\n    r1 = 2,\n\n    //% block=\"P2\"\n\n    r2 = 3\n\n\n\n}\nenum Ultrasonic_pin {\n\n    //% block=\"(P13,P0)\"\n\n    u1 = 13,\n\n    //% block=\"(P14,P1)\"\n\n    u3 = 114,\n\n    //% block=\"(P9,P12)\"\n\n    u4 = 129,\n\n    //% block=\"(P15,P2)\"\n\n    u5 = 215\n\n}\nenum Recodpin {\n\n    //% block=\"(P0,P13)\"\n\n    rc1 = 13,\n    //% block=\"(P1,P14)\"\n\n    rc2 = 114,\n\n    //% block=\"(P2,P15)\"\n\n    rc3 = 215\n\n}\nenum Record_list {//\n\n    //% block=\"machine gun burst\"\n\n    rl1 = 1,\n\n    //% block=\"laser fire\"\n\n    rl2 = 2,\n\n    //% block=\"racing acceleration\"\n\n    rl3 = 3,\n    //% block=\"battle start\"\n\n    rl4 = 4,\n    //% block=\"countdown\"\n\n    rl5 = 5,\n    //% block=\"recorded audio\"\n\n    rl6 = 6\n\n}\nenum PingUnit {\n\n    //% block=\"centimeters\"\n\n    Centimeters,\n\n    //% block=\"microseconds\"\n\n    MicroSeconds,\n\n\n\n    //% block=\"inches\"\n\n    Inches\n\n}\nenum Grayscale_pin {\n\n    //% block=\"P13\"\n\n    g0 = 1,\n\n    //% block=\"P16\"\n\n    g1 = 2,\n\n    //% block=\"P0\"\n\n    g2 = 3,\n\n    //% block=\"P10\"\n\n    g3 = 4,\n\n    //% block=\"P14\"\n\n    g4 = 5,\n\n    //% block=\"P12\"\n\n    g5 = 6,\n\n    //% block=\"P1\"\n\n    g6 = 7,\n\n    //% block=\"P9\"\n\n    g7 = 8,\n\n    //% block=\"P15\"\n\n    g8 = 9,\n\n    //% block=\"P8\"\n\n    g9 = 10,\n\n    //% block=\"P2\"\n\n    g10 = 11,\n\n    //% block=\"P7\"\n\n    g11 = 12\n\n}\nenum gs {\n\n    //% block=\"up\"\n\n    g0 = 1,\n\n    //% block=\"down\"\n\n    g1 = 2,\n\n    //% block=\"left\"\n\n    g2 = 3,\n\n    //% block=\"right\"\n\n    g3 = 4\n\n\n\n}\nenum PINs {\n\n    P0,\n\n    P1,\n\n    P2,\n\n    P3,\n\n    P4,\n\n    P5,\n\n    P6,\n\n    P7,\n\n    P8,\n\n    P9,\n\n    P10,\n\n    P11,\n\n    P12,\n\n    P13,\n\n    P14,\n\n    P15,\n\n    P16,\n\n    P19,\n\n    P20\n\n}\nenum TMP36Type {\n\n    //% block=\"(℃)\" enumval=0\n\n    TMP36_temperature_C,\n\n\n\n    //% block=\"(℉)\" enumval=1\n\n    TMP36_temperature_F,\n\n}\nenum RGB {\n\n    //% block=\"red\"\n\n    RED,\n\n    //% block=\"green\"\n\n    GREEN,\n\n    //% block=\"blue\"\n\n    BLUE,\n\n    //% block=\"clear\"\n\n    CLEAR\n\n}\nenum NeoPixelColors {\n\n    //% block=red\n\n    Red = 0xFF0000,\n\n    //% block=orange\n\n    Orange = 0xFFA500,\n\n    //% block=yellow\n\n    Yellow = 0xFFFF00,\n\n    //% block=green\n\n    Green = 0x00FF00,\n\n    //% block=blue\n\n    Blue = 0x0000FF,\n\n    //% block=indigo\n\n    Indigo = 0x4b0082,\n\n    //% block=violet\n\n    Violet = 0x8a2be2,\n\n    //% block=purple\n\n    Purple = 0xFF00FF,\n\n    //% block=white\n\n    White = 0xFFFFFF,\n\n    //% block=black\n\n    Black = 0x000000\n\n}\nenum NeoPixelMode {\n\n    //% block=\"GRB\"\n\n    RGB = 1,\n\n    //% block=\"RGB+W\"\n\n    RGBW = 2,\n\n    //% block=\"RGB\"\n\n    RGB_RGB = 3\n\n}\nnamespace Microbit {\n\n\n\n    export enum DHT11_state {\n\n        //% block=\"temperature(℃)\" enumval=0\n\n        DHT11_temperature_C,\n\n\n\n        //% block=\"humidity(0~100)\" enumval=1\n\n        DHT11_humidity,\n\n    }\n\n\n\n    export enum Distance_Unit_List {\n\n        //% block=\"centimeters\" \n\n        Distance_Unit_cm,\n\n\n\n        //% block=\"inches\"\n\n        Distance_Unit_inch,\n\n    }\n\n\n\n    //% blockId=buttonState\n\n    //% weight=27\n\n    //% buttonpin.fieldEditor=\"gridpicker\"\n\n    //% buttonpin.fieldOptions.width=220\n\n    //% buttonpin.fieldOptions.columns=2\n\n    //% block=\"Button Sensor %buttonpin\"\n\n    //% subcategory=Sensor\n\n    export function buttonState(buttonpin: Write_pin): number {\n\n        let pin16\n\n        if (buttonpin == 1) {\n\n\n\n            pin16 = DigitalPin.P0;\n\n        }\n\n        if (buttonpin == 2) {\n\n            pin16 = DigitalPin.P16;\n\n        }\n\n        if (buttonpin == 3) {\n\n            pin16 = DigitalPin.P1;\n\n        }\n\n        if (buttonpin == 4) {\n\n\n\n            pin16 = DigitalPin.P12;\n\n        }\n\n        if (buttonpin == 5) {\n\n            pin16 = DigitalPin.P2;\n\n        }\n\n        if (buttonpin == 6) {\n\n            pin16 = DigitalPin.P8;\n\n        }\n\n\n\n\n\n        return pins.digitalReadPin(pin16);\n\n    }\n\n\n\n    //% blockId=hState\n\n    //% weight=27\n\n    //% hallpin.fieldEditor=\"gridpicker\"\n\n    //% hallpin.fieldOptions.width=220\n\n    //% hallpin.fieldOptions.columns=1\n\n    //% block=\"Hall Sensor %hallpin\"\n\n    //% subcategory=Sensor\n\n    export function hState(hallpin: Read_pin): number {\n\n        let pin18\n\n        if (hallpin == 1) {\n\n\n\n            pin18 = AnalogPin.P0;\n\n        }\n\n        if (hallpin == 2) {\n\n            pin18 = AnalogPin.P1;\n\n        }\n\n        if (hallpin == 3) {\n\n            pin18 = AnalogPin.P2;\n\n        }\n        if (pins.analogReadPin(pin18) < 512)\n            return (0);\n        else\n            return (1);\n\n    }\n\n\n\n    //% blockId=farState\n\n    //% weight=38\n\n    //% farStatepin.fieldEditor=\"gridpicker\"\n\n    //% farStatepin.fieldOptions.width=220\n\n    //% farStatepin.fieldOptions.columns=2\n\n    //% block=\"Long-range Photoelectric Sensor %farStatepin\"\n\n    //% subcategory=Sensor\n\n    export function farState(farStatepin: Write_pin): number {\n\n        let pin17\n\n        if (farStatepin == 1) {\n\n\n\n            pin17 = DigitalPin.P0;\n\n        }\n\n        if (farStatepin == 2) {\n\n            pin17 = DigitalPin.P16;\n\n        }\n\n        if (farStatepin == 3) {\n\n            pin17 = DigitalPin.P1;\n\n        }\n\n        if (farStatepin == 4) {\n\n\n\n            pin17 = DigitalPin.P12;\n\n        }\n\n        if (farStatepin == 5) {\n\n            pin17 = DigitalPin.P2;\n\n        }\n\n        if (farStatepin == 6) {\n\n            pin17 = DigitalPin.P8;\n\n        }\n\n        return pins.digitalReadPin(pin17);\n\n    }\n\n\n\n    //% blockId=potentiometerRead\n\n    //% weight=37\n\n    //% potentiometerpin.fieldEditor=\"gridpicker\"\n\n    //% potentiometerpin.fieldOptions.width=220\n\n    //% potentiometerpin.fieldOptions.columns=1\n\n    //% block=\"Potentiometer %potentiometerpin\"\n\n    //% subcategory=Sensor\n\n    export function potentiometerRead(potentiometerpin: Read_pin): number {\n\n        let pin15\n\n        if (potentiometerpin == 1) {\n\n\n\n            pin15 = AnalogPin.P0;\n\n        }\n\n        if (potentiometerpin == 2) {\n\n            pin15 = AnalogPin.P1;\n\n        }\n\n        if (potentiometerpin == 3) {\n\n            pin15 = AnalogPin.P2;\n\n        }\n\n        return pins.analogReadPin(pin15);\n\n    }\n\n\n\n    //% blockId=\"ReadGrayLevel\" block=\"Grayscale Sensor %graylevelpin\"\n\n    //% weight=36\n\n    //% graylevelpin.fieldEditor=\"gridpicker\"\n\n    //% graylevelpin.fieldOptions.width=220\n\n    //% graylevelpin.fieldOptions.columns=1\n\n    //% subcategory=Sensor\n\n    export function ReadGrayLevel(graylevelpin: Read_pin): number {\n\n        let voltage7 = 0;\n\n        let grayLevel = 0;\n\n        let pin13\n\n        if (graylevelpin == 1) {\n\n\n\n            pin13 = AnalogPin.P0;\n\n        }\n\n        if (graylevelpin == 2) {\n\n            pin13 = AnalogPin.P1;\n\n        }\n\n        if (graylevelpin == 3) {\n\n            pin13 = AnalogPin.P2;\n\n        }\n\n        voltage7 = pins.map(\n\n            pins.analogReadPin(pin13),\n\n            0,\n\n            1023,\n\n            80,\n\n            1023\n\n        );\n\n        grayLevel = voltage7;\n\n        return Math.round(grayLevel);\n\n    }\n\n\n\n    //% blockId=\"readlightintensity\" block=\"Photosensitive Sensor %lightintensitypin\"\n\n    //% weight=35\n\n    //% lightintensitypin.fieldEditor=\"gridpicker\"\n\n    //% lightintensitypin.fieldOptions.width=220\n\n    //% lightintensitypin.fieldOptions.columns=1\n\n    //% subcategory=Sensor\n\n    export function ReadLightIntensity(lightintensitypin: Read_pin): number {\n\n        let voltage2 = 0;\n\n        let lightintensity = 0;\n\n        let pin2\n\n        if (lightintensitypin == 1) {\n\n            pin2 = AnalogPin.P0;\n\n\n\n        }\n\n        if (lightintensitypin == 2) {\n\n            pin2 = AnalogPin.P1;\n\n        }\n\n        if (lightintensitypin == 3) {\n\n            pin2 = AnalogPin.P2;\n\n\n\n        }\n\n        voltage2 = pins.map(\n\n            pins.analogReadPin(pin2),\n\n            0,\n\n            1023,\n\n            0,\n\n            1023\n\n        );\n\n        lightintensity = voltage2;\n\n        return Math.round(1023 - lightintensity);\n\n\n\n    }\n\n\n\n    //% blockId=\"Readflame\" block=\"Flame Sensor %flamepin\"\n\n    //% weight=34\n\n    //% flamepin.fieldEditor=\"gridpicker\"\n\n    //% flamepin.fieldOptions.width=220\n\n    //% flamepin.fieldOptions.columns=1\n\n    //% subcategory=Sensor\n\n    export function Readflame(flamepin: Read_pin): number {\n\n        let voltage6 = 0;\n\n        let flame = 0;\n\n        let pin12\n\n        if (flamepin == 1) {\n\n\n\n            pin12 = AnalogPin.P0;\n\n        }\n\n        if (flamepin == 2) {\n\n            pin12 = AnalogPin.P1;\n\n        }\n\n        if (flamepin == 3) {\n\n            pin12 = AnalogPin.P2;\n\n        }\n\n        voltage6 = pins.map(\n\n            pins.analogReadPin(pin12),\n\n            0,\n\n            1023,\n\n            0,\n\n            1023\n\n        );\n\n        flame = voltage6;\n\n        return Math.round(1023 - flame);\n\n    }\n\n\n\n    //% blockId=\"octopus_ReadWaterLevel\" block=\"Water Level Sensor %waterlevelpin\"\n\n    //% weight=33\n\n    //% waterlevelpin.fieldEditor=\"gridpicker\"\n\n    //% waterlevelpin.fieldOptions.width=220\n\n    //% waterlevelpin.fieldOptions.columns=1\n\n    //% subcategory=Sensor\n\n\n\n    export function ReadWaterLevel(waterlevelpin: Read_pin): number {\n\n        let voltage4 = 0;\n\n        let waterLevel = 0;\n\n        let pin10\n\n        if (waterlevelpin == 1) {\n\n\n\n            pin10 = AnalogPin.P0;\n\n        }\n\n        if (waterlevelpin == 2) {\n\n            pin10 = AnalogPin.P1;\n\n        }\n\n        if (waterlevelpin == 3) {\n\n            pin10 = AnalogPin.P2;\n\n        }\n\n        voltage4 = pins.analogReadPin(pin10);\n\n        if (voltage4 > 620) { waterLevel = 100; }\n\n        else if (voltage4 > 618) { waterLevel = 98; }\n\n        else if (voltage4 > 617) { waterLevel = 96; }\n\n        else if (voltage4 > 616) { waterLevel = 94; }\n\n        else if (voltage4 > 614) { waterLevel = 92; }\n\n        else if (voltage4 > 612) { waterLevel = 90; }\n\n        else if (voltage4 > 610) { waterLevel = 88; }\n\n        else if (voltage4 > 609) { waterLevel = 86; }\n\n        else if (voltage4 > 607) { waterLevel = 85; }\n\n        else if (voltage4 > 606) { waterLevel = 83; }\n\n        else if (voltage4 > 605) { waterLevel = 81; }\n\n        else if (voltage4 > 604) { waterLevel = 80; }\n\n        else if (voltage4 > 603) { waterLevel = 78; }\n\n        else if (voltage4 > 602) { waterLevel = 77; }\n\n        else if (voltage4 > 600) { waterLevel = 75; }\n\n        else if (voltage4 > 598) { waterLevel = 73; }\n\n        else if (voltage4 > 596) { waterLevel = 72; }\n\n        else if (voltage4 > 594) { waterLevel = 70; }\n\n        else if (voltage4 > 592) { waterLevel = 68; }\n\n        else if (voltage4 > 590) { waterLevel = 65; }\n\n        else if (voltage4 > 588) { waterLevel = 63; }\n\n        else if (voltage4 > 586) { waterLevel = 62; }\n\n        else if (voltage4 > 583) { waterLevel = 60; }\n\n        else if (voltage4 > 580) { waterLevel = 58; }\n\n        else if (voltage4 > 575) { waterLevel = 56; }\n\n        else if (voltage4 > 574) { waterLevel = 55; }\n\n        else if (voltage4 > 573) { waterLevel = 54; }\n\n\n\n        else if (voltage4 > 572) { waterLevel = 53; }\n\n        else if (voltage4 > 570) { waterLevel = 52; }\n\n        else if (voltage4 > 568) { waterLevel = 51; }\n\n        else if (voltage4 > 566) { waterLevel = 50; }\n\n        else if (voltage4 > 563) { waterLevel = 49; }\n\n        else if (voltage4 > 560) { waterLevel = 48; }\n\n        else if (voltage4 > 557) { waterLevel = 47; }\n\n        else if (voltage4 > 554) { waterLevel = 46; }\n\n        else if (voltage4 > 551) { waterLevel = 45; }\n\n        else if (voltage4 > 548) { waterLevel = 44; }\n\n        else if (voltage4 > 545) { waterLevel = 43; }\n\n        else if (voltage4 > 542) { waterLevel = 42; }\n\n        else if (voltage4 > 539) { waterLevel = 41; }\n\n        else if (voltage4 > 536) { waterLevel = 40; }\n\n        else if (voltage4 > 533) { waterLevel = 39; }\n\n        else if (voltage4 > 530) { waterLevel = 38; }\n\n        else if (voltage4 > 527) { waterLevel = 37; }\n\n        else if (voltage4 > 523) { waterLevel = 36; }\n\n        else if (voltage4 > 516) { waterLevel = 35; }\n\n        else if (voltage4 > 510) { waterLevel = 34; }\n\n        else if (voltage4 > 506) { waterLevel = 33; }\n\n        else if (voltage4 > 500) { waterLevel = 32; }\n\n        else if (voltage4 > 497) { waterLevel = 31; }\n\n        else if (voltage4 > 494) { waterLevel = 30; }\n\n        else if (voltage4 > 481) { waterLevel = 29; }\n\n        else if (voltage4 > 478) { waterLevel = 28; }\n\n        else if (voltage4 > 475) { waterLevel = 27; }\n\n        else if (voltage4 > 472) { waterLevel = 26; }\n\n        else if (voltage4 > 469) { waterLevel = 25; }\n\n        else if (voltage4 > 466) { waterLevel = 24; }\n\n        else if (voltage4 > 463) { waterLevel = 23; }\n\n        else if (voltage4 > 460) { waterLevel = 22; }\n\n        else if (voltage4 > 457) { waterLevel = 21; }\n\n        else if (voltage4 > 454) { waterLevel = 19; }\n\n        else if (voltage4 > 451) { waterLevel = 18; }\n\n        else if (voltage4 > 448) { waterLevel = 17; }\n\n        else if (voltage4 > 445) { waterLevel = 16; }\n\n        else if (voltage4 > 442) { waterLevel = 15; }\n\n        else if (voltage4 > 439) { waterLevel = 14; }\n\n        else if (voltage4 > 436) { waterLevel = 13; }\n\n        else if (voltage4 > 433) { waterLevel = 12; }\n\n        else if (voltage4 > 430) { waterLevel = 11; }\n\n        else if (voltage4 > 427) { waterLevel = 10; }\n\n        else if (voltage4 > 424) { waterLevel = 9; }\n\n        else if (voltage4 > 421) { waterLevel = 8; }\n\n        else if (voltage4 > 418) { waterLevel = 7; }\n\n        else if (voltage4 > 415) { waterLevel = 6; }\n\n        else if (voltage4 > 412) { waterLevel = 5; }\n\n        else if (voltage4 > 409) { waterLevel = 4; }\n\n        else if (voltage4 > 406) { waterLevel = 3; }\n\n        else if (voltage4 > 403) { waterLevel = 2; }\n\n        else if (voltage4 > 400) { waterLevel = 1; }\n\n        else { waterLevel = 0; }\n\n\n\n        return Math.round(waterLevel);\n\n    }\n\n\n\n    //% blockId=\"ReadGasConcentration\" block=\"MQ-2 Gas Sensor %gasconcentrationpin\"\n\n    //% weight=32\n\n    //% gasconcentrationpin.fieldEditor=\"gridpicker\"\n\n    //% gasconcentrationpin.fieldOptions.width=220\n\n    //% gasconcentrationpin.fieldOptions.columns=1\n\n    //% subcategory=Sensor\n\n    export function ReadGasConcentration(gasconcentrationpin: Read_pin): number {\n\n        let voltage5 = 0;\n\n        let gasConcentration = 0;\n\n        let pin11\n\n        if (gasconcentrationpin == 1) {\n\n\n\n            pin11 = AnalogPin.P0;\n\n        }\n\n        if (gasconcentrationpin == 2) {\n\n            pin11 = AnalogPin.P1;\n\n        }\n\n        if (gasconcentrationpin == 3) {\n\n            pin11 = AnalogPin.P2;\n\n        }\n\n        voltage5 = pins.map(\n\n            pins.analogReadPin(pin11),\n\n            0,\n\n            1023,\n\n            0,\n\n            1023\n\n        );\n\n        gasConcentration = voltage5;\n\n        return Math.round(gasConcentration);\n\n    }\n\n\n\n    //% blockId=\"readsoilmoisture\" block=\"Soil moisture Sensor %soilhumiditypin\"\n\n    //% weight=31\n\n    //% soilmoisturepin.fieldEditor=\"gridpicker\"\n\n    //% soilmoisturepin.fieldOptions.width=220\n\n    //% soilmoisturepin.fieldOptions.columns=1\n\n    //% subcategory=Sensor\n\n    export function ReadSoilHumidity(soilmoisturepin: Read_pin): number {\n\n        let voltage = 0;\n\n        let soilmoisture = 0;\n\n        let pin\n\n        if (soilmoisturepin == 1) {\n\n            pin = AnalogPin.P0;\n\n        }\n\n        if (soilmoisturepin == 2) {\n\n            pin = AnalogPin.P1;\n\n        }\n\n        if (soilmoisturepin == 3) {\n\n            pin = AnalogPin.P2;\n\n\n\n        }\n\n        voltage = pins.map(\n\n            pins.analogReadPin(pin),\n\n            0,\n\n            1023,\n\n            0,\n\n            1023\n\n        );\n\n        soilmoisture = voltage;\n\n        return Math.round(soilmoisture);\n\n    }\n\n\n\n    //% blockId=\"readWaterTemp\" block=\"Temperature Sensor %waterproofpin\"\n\n    //% weight=30\n\n    //% waterproofpin.fieldEditor=\"gridpicker\"\n\n    //% waterproofpin.fieldOptions.width=220\n\n    //% waterproofpin.fieldOptions.columns=1\n\n    //% subcategory=Sensor\n\n    export function readWaterTemp(waterproofpin: Read_pin): number {\n\n        let voltage22 = 0;\n\n        let waterProofTemp = 0;\n\n        let pin14\n\n        if (waterproofpin == 1) {\n\n\n\n            pin14 = AnalogPin.P0;\n\n        }\n\n        if (waterproofpin == 2) {\n\n            pin14 = AnalogPin.P1;\n\n        }\n\n        if (waterproofpin == 3) {\n\n            pin14 = AnalogPin.P2;\n\n        }\n\n        voltage22 = pins.analogReadPin(pin14);//%获得原始值\n\n        if (voltage22 > 1001) { waterProofTemp = 100; }\n\n        else if (voltage22 > 1000) { waterProofTemp = 98; }\n\n        else if (voltage22 > 999) { waterProofTemp = 97; }\n\n        else if (voltage22 > 998) { waterProofTemp = 96; }\n\n        else if (voltage22 > 997) { waterProofTemp = 95; }\n\n        else if (voltage22 > 996) { waterProofTemp = 93; }\n\n        else if (voltage22 > 995) { waterProofTemp = 92; }\n\n        else if (voltage22 > 994) { waterProofTemp = 91; }\n\n        else if (voltage22 > 993) { waterProofTemp = 90; }\n\n        else if (voltage22 > 992) { waterProofTemp = 89; }\n\n        else if (voltage22 > 991) { waterProofTemp = 88; }\n\n        else if (voltage22 > 990) { waterProofTemp = 87; }\n\n        else if (voltage22 > 989) { waterProofTemp = 86; }\n\n        else if (voltage22 > 988) { waterProofTemp = 85; }\n\n        else if (voltage22 > 987) { waterProofTemp = 84; }\n\n        else if (voltage22 > 986) { waterProofTemp = 83; }\n\n        else if (voltage22 > 985) { waterProofTemp = 82; }\n\n        else if (voltage22 > 984) { waterProofTemp = 81; }\n\n        else if (voltage22 > 982) { waterProofTemp = 80; }\n\n        else if (voltage22 > 981) { waterProofTemp = 79; }\n\n        else if (voltage22 > 980) { waterProofTemp = 78; }\n\n        else if (voltage22 > 978) { waterProofTemp = 77; }\n\n        else if (voltage22 > 977) { waterProofTemp = 76; }\n\n        else if (voltage22 > 975) { waterProofTemp = 75; }\n\n        else if (voltage22 > 974) { waterProofTemp = 74; }\n\n        else if (voltage22 > 972) { waterProofTemp = 73; }\n\n        else if (voltage22 > 971) { waterProofTemp = 72; }\n\n        else if (voltage22 > 969) { waterProofTemp = 71; }\n\n        else if (voltage22 > 967) { waterProofTemp = 70; }\n\n        else if (voltage22 > 965) { waterProofTemp = 69; }\n\n        else if (voltage22 > 963) { waterProofTemp = 68; }\n\n        else if (voltage22 > 961) { waterProofTemp = 67; }\n\n        else if (voltage22 > 959) { waterProofTemp = 66; }\n\n        else if (voltage22 > 957) { waterProofTemp = 65; }\n\n        else if (voltage22 > 955) { waterProofTemp = 64; }\n\n        else if (voltage22 > 953) { waterProofTemp = 63; }\n\n        else if (voltage22 > 950) { waterProofTemp = 62; }\n\n        else if (voltage22 > 948) { waterProofTemp = 61; }\n\n        else if (voltage22 > 943) { waterProofTemp = 59; }\n\n        else if (voltage22 > 940) { waterProofTemp = 58; }\n\n        else if (voltage22 > 937) { waterProofTemp = 57; }\n\n        else if (voltage22 > 934) { waterProofTemp = 56; }\n\n        else if (voltage22 > 931) { waterProofTemp = 55; }\n\n        else if (voltage22 > 928) { waterProofTemp = 54; }\n\n        else if (voltage22 > 924) { waterProofTemp = 53; }\n\n        else if (voltage22 > 921) { waterProofTemp = 52; }\n\n        else if (voltage22 > 917) { waterProofTemp = 51; }\n\n        else if (voltage22 > 914) { waterProofTemp = 51; }\n\n        else if (voltage22 > 910) { waterProofTemp = 49; }\n\n        else if (voltage22 > 906) { waterProofTemp = 48; }\n\n        else if (voltage22 > 902) { waterProofTemp = 47; }\n\n        else if (voltage22 > 898) { waterProofTemp = 46; }\n\n        else if (voltage22 > 893) { waterProofTemp = 45; }\n\n        else if (voltage22 > 889) { waterProofTemp = 44; }\n\n        else if (voltage22 > 884) { waterProofTemp = 43; }\n\n        else if (voltage22 > 879) { waterProofTemp = 42; }\n\n        else if (voltage22 > 874) { waterProofTemp = 41; }\n\n        else if (voltage22 > 869) { waterProofTemp = 40; }\n\n        else if (voltage22 > 864) { waterProofTemp = 39; }\n\n        else if (voltage22 > 858) { waterProofTemp = 38; }\n\n        else if (voltage22 > 852) { waterProofTemp = 37; }\n\n        else if (voltage22 > 846) { waterProofTemp = 36; }\n\n        else if (voltage22 > 840) { waterProofTemp = 35; }\n\n        else if (voltage22 > 834) { waterProofTemp = 34; }\n\n        else if (voltage22 > 827) { waterProofTemp = 33; }\n\n        else if (voltage22 > 821) { waterProofTemp = 32; }\n\n        else if (voltage22 > 814) { waterProofTemp = 31; }\n\n        else if (voltage22 > 806) { waterProofTemp = 30; }\n\n        else if (voltage22 > 799) { waterProofTemp = 29; }\n\n        else if (voltage22 > 791) { waterProofTemp = 28; }\n\n        else if (voltage22 > 784) { waterProofTemp = 27; }\n\n        else if (voltage22 > 776) { waterProofTemp = 26; }\n\n        else if (voltage22 > 767) { waterProofTemp = 25; }\n\n        else if (voltage22 > 759) { waterProofTemp = 24; }\n\n        else if (voltage22 > 750) { waterProofTemp = 23; }\n\n        else if (voltage22 > 741) { waterProofTemp = 22; }\n\n        else if (voltage22 > 732) { waterProofTemp = 21; }\n\n        else if (voltage22 > 713) { waterProofTemp = 19; }\n\n        else if (voltage22 > 703) { waterProofTemp = 18; }\n\n        else if (voltage22 > 692) { waterProofTemp = 17; }\n\n        else if (voltage22 > 682) { waterProofTemp = 16; }\n\n        else if (voltage22 > 671) { waterProofTemp = 15; }\n\n        else if (voltage22 > 661) { waterProofTemp = 14; }\n\n        else if (voltage22 > 650) { waterProofTemp = 13; }\n\n        else if (voltage22 > 638) { waterProofTemp = 12; }\n\n        else if (voltage22 > 627) { waterProofTemp = 11; }\n\n        else if (voltage22 > 615) { waterProofTemp = 10; }\n\n        else if (voltage22 > 604) { waterProofTemp = 9; }\n\n        else if (voltage22 > 592) { waterProofTemp = 8; }\n\n        else if (voltage22 > 579) { waterProofTemp = 7; }\n\n        else if (voltage22 > 567) { waterProofTemp = 6; }\n\n        else if (voltage22 > 555) { waterProofTemp = 5; }\n\n        else if (voltage22 > 542) { waterProofTemp = 4; }\n\n        else if (voltage22 > 530) { waterProofTemp = 3; }\n\n        else if (voltage22 > 517) { waterProofTemp = 2; }\n\n        else if (voltage22 > 504) { waterProofTemp = 1; }\n\n        else { waterProofTemp = 0; }\n\n        return waterProofTemp;\n\n    }\n\n\n\n \n\n    //% blockId=sonarbit\n\n    //% weight=29\n\n\n    //% subcategory=Sensor\n\n    //% blockId=sonar_ping block=\"Ultrasonic Sensor %ultpins units %unit\"\n\n    //% ultpins.fieldEditor=\"gridpicker\"\n\n    //% ultpins.fieldOptions.width=220\n\n    //% ultpins.fieldOptions.columns=2\n\n    export function ping(ultpins: Ultrasonic_pin, unit: PingUnit, maxCmDistance = 500): number {\n\n        // send pulse\n\n\n\n        let d\n\n        let distance\n\n        let echopin\n\n        let trigpin\n\n        if (ultpins == 13) {\n\n            trigpin = DigitalPin.P0;\n\n            echopin = DigitalPin.P13;\n\n        }\n\n        if (ultpins == 114) {\n\n            trigpin = DigitalPin.P1;\n\n            echopin = DigitalPin.P14;\n\n        }\n\n        if (ultpins == 215) {\n\n            trigpin = DigitalPin.P2;\n\n            echopin = DigitalPin.P15;\n\n        }\n\n        if (ultpins == 87) {\n\n            trigpin = DigitalPin.P8;\n\n            echopin = DigitalPin.P7;\n\n        }\n\n        if (ultpins == 129) {\n\n            trigpin = DigitalPin.P12;\n\n            echopin = DigitalPin.P9;\n\n        }\n\n        if (ultpins == 1610) {\n\n            trigpin = DigitalPin.P16;\n\n            echopin = DigitalPin.P10;\n\n        }\n\n        pins.setPull(trigpin, PinPullMode.PullNone);\n\n        pins.digitalWritePin(trigpin, 0);\n\n        control.waitMicros(2);\n\n        pins.digitalWritePin(trigpin, 1);\n\n        control.waitMicros(10);\n\n        pins.digitalWritePin(trigpin, 0);\n\n\n\n        // read pulse\n\n        d = pins.pulseIn(echopin, PulseValue.High, maxCmDistance * 50);\n\n        distance = d * 34 / 2 / 1000 * 3 / 2;\n\n        switch (unit) {\n\n            case PingUnit.Centimeters: return Math.round(distance);\n\n            case PingUnit.Inches: return Math.round(distance / 30.48);\n\n            default: return Math.round(d);\n\n        }\n\n    }\n\n\n\n    //////人体红外/////\n\n    //% weight=27\n\n    //% pirpin.fieldEditor=\"gridpicker\"\n\n    //% pirpin.fieldOptions.width=220\n\n    //% pirpin.fieldOptions.columns=2\n\n    //% blockId=\"PIR\" block=\"PIR Sensor %pirpin detects motion\"\n\n    //% subcategory=Sensor \n\n    export function pir(pirpin: Write_pin): number {\n\n        let pin48\n        let rt\n\n        if (pirpin == 1) {\n\n\n\n            pin48 = DigitalPin.P0;\n\n        }\n\n        if (pirpin == 2) {\n\n            pin48 = DigitalPin.P16;\n\n        }\n\n        if (pirpin == 3) {\n\n            pin48 = DigitalPin.P1;\n\n        }\n\n        if (pirpin == 4) {\n\n\n\n            pin48 = DigitalPin.P12;\n\n        }\n\n        if (pirpin == 5) {\n\n            pin48 = DigitalPin.P2;\n\n        }\n\n        if (pirpin == 6) {\n\n            pin48 = DigitalPin.P8;\n\n        }\n\n\n\n        if (pins.digitalReadPin(pin48) == 1) {\n\n            rt = 0\n\n        }\n\n        else {\n\n            rt = 1\n\n        }\n        return rt\n\n    }\n\n\n    /////////摇杆////////////////////\n\n    export enum rocket {\n        //% block=\"X\"\n\n        x = 1,\n\n        //% block=\"Y\"\n\n        y = 2\n    }\n    export enum rock {\n        //% block=\"up\"\n\n        orient1 = 2,\n\n        //% block=\"down\"\n\n        orient2 = 1,\n\n        //% block=\"left\"\n\n        orient3 = 4,\n\n        //% block=\"right\"\n\n        orient4 = 3\n    }\n\n    //% weight=27\n\n    //% direction.fieldEditor=\"gridpicker\"\n\n    //% direction.fieldOptions.width=220\n\n    //% direction.fieldOptions.columns=2\n\n    //% blockId=\"ROCKET\" block=\"Joystick %direction moved\"\n\n    //% subcategory=Sensor \n\n    export function rocker(direction: rocket): number {\n\n        let GetBuff = pins.createBuffer(3)\n\n        GetBuff = pins.i2cReadBuffer(97, 3)\n\n        let re = GetBuff.getNumber(NumberFormat.Int8BE, direction)\n        if (direction == 2) {\n            return -re\n        } else {\n            return re\n        }\n        // re = -re\n\n\n    }\n    //% weight=27\n\n    //% direction.fieldEditor=\"gridpicker\"\n\n    //% direction.fieldOptions.width=220\n\n    //% direction.fieldOptions.columns=2\n\n    //% blockId=\"ROCKETORI\" block=\"Joystick detected %orientation \"\n\n    //% subcategory=Sensor \n\n    export function rockerori(orientation: rock): boolean {\n\n        let GetBuff2 = pins.createBuffer(3)\n\n        GetBuff2 = pins.i2cReadBuffer(97, 3)\n        let ud = GetBuff2.getNumber(NumberFormat.Int8BE, 2)\n        let lr = GetBuff2.getNumber(NumberFormat.Int8BE, 1)\n        let flag\n        if (orientation == 1) {\n            if (ud > 50)\n                flag = true\n            else\n                flag = false\n        }\n        if (orientation == 2) {\n            if (ud < -50)\n                flag = true\n            else\n                flag = false\n        }\n        if (orientation == 4) {\n            if (lr < -50)\n                flag = true\n            else\n                flag = false\n        }\n        if (orientation == 3) {\n            if (lr > 50)\n                flag = true\n            else\n                flag = false\n        }\n        return flag\n\n    }\n\n\n\n    ////////////////执行器/////////////////////////////////////\n\n    export enum enPos {\n\n        //% blockId=\"forward\" block=\"forward\"\n\n        forward = 1,\n\n        //% blockId=\"stop\" block=\"back\"\n\n        stop = 2\n\n    }\n\n    export enum enMotorcolor {\n        //% block=\"red\"\n\n        red = 81,\n\n        //% block=\"green\"\n\n        blue = 82,\n\n        //% block=\"blue\"\n\n        green = 83,\n\n        //% block=\"yellow\"\n\n        yellow = 84\n\n    }\n\n    export enum enServo {\n        S1 = 0,\n        S2,\n        S3,\n        S4\n    }\n\n\n\n    export enum enMotors {\n\n\n\n        M2 = 10,\n\n        M3 = 12,\n\n        M1 = 8,\n\n        M4 = 14\n\n    }\n\n\n    const PCA9685_ADD = 0x40\n\n    const MODE1 = 0x00\n\n    const SUBADR1 = 0x02\n\n    const SUBADR2 = 0x03\n\n    const SUBADR3 = 0x04\n\n    const PRESCALE = 0xFE\n\n    const LED0_ON_L = 0x06\n\n    const LED0_ON_H = 0x07\n\n    const LED0_OFF_L = 0x08\n\n    const LED0_OFF_H = 0x09\n\n    const ALL_LED_ON_L = 0xFA\n\n    const ALL_LED_ON_H = 0xFB\n\n    const ALL_LED_OFF_L = 0xFC\n\n    const ALL_LED_OFF_H = 0xFD\n\n\n\n    const STP_CHA_L = 2047\n\n    const STP_CHA_H = 4095\n\n\n\n    const STP_CHB_L = 1\n\n    const STP_CHB_H = 2047\n\n\n\n    const STP_CHC_L = 1023\n\n    const STP_CHC_H = 3071\n\n\n\n    const STP_CHD_L = 3071\n\n    const STP_CHD_H = 1023\n\n\n\n    let initialized = false\n\n    let caraddress1 = 81\n    let caraddress2 = 82\n\n\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n\n        let buf6 = pins.createBuffer(2)\n\n        buf6[0] = reg\n\n        buf6[1] = value\n\n        pins.i2cWriteBuffer(addr, buf6)\n\n    }\n\n\n\n    function i2cread(addr: number, reg: number) {\n\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n\n        return val;\n\n    }\n\n\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADD, MODE1, 0x00)\n        setFreq(50);\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADD, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADD, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);\n    }\n\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        if (!initialized) {\n            initPCA9685();\n        }\n        let buf22 = pins.createBuffer(5);\n        buf22[0] = LED0_ON_L + 4 * channel;\n        buf22[1] = on & 0xff;\n        buf22[2] = (on >> 8) & 0xff;\n        buf22[3] = off & 0xff;\n        buf22[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADD, buf22);\n    }\n\n\n\n\n    //% blockId=SuperBit_MotorRun \n\n    //% weight=27\n\n    //% index.fieldEditor=\"gridpicker\"\n\n    //% index.fieldOptions.width=220\n\n    //% index.fieldOptions.columns=2\n\n    //% block=\"DC Motor|%index|speed(-255~255) %speed\"\n\n    //% speed.min=-255 speed.max=255\n\n    //% subcategory=Movement\n\n    export function MotorRun(index: enMotors, speed: number): void {\n\n        if (!initialized) {\n\n            initPCA9685()\n\n        }\n\n        speed = speed * 16; // map 255 to 4096\n\n        if (speed >= 4096) {\n\n            speed = 4095\n\n        }\n\n        if (speed <= -4096) {\n\n            speed = -4095\n\n        }\n\n\n\n        let a = index\n\n        let b = index + 1\n\n\n\n        if (a > 10) {\n\n            if (speed >= 0) {\n\n                setPwm(a, 0, speed)\n\n                setPwm(b, 0, 0)\n\n            } else {\n\n                setPwm(a, 0, 0)\n\n                setPwm(b, 0, -speed)\n\n            }\n\n        }\n\n        else {\n\n            if (speed >= 0) {\n\n                setPwm(b, 0, speed)\n\n                setPwm(a, 0, 0)\n\n            } else {\n\n                setPwm(b, 0, 0)\n\n                setPwm(a, 0, -speed)\n\n            }\n\n        }\n\n    }\n    //% blockId=SuperBit_runMotor block=\"|%motoraddress|Motor rotate at|%speed|\"\n\n    //% speed.min=-100 speed.max=100\n\n    //% parts=\"SuperBit_runMotor\" subcategory=Movement group=\"Servo Motor\"\n\n    export function runMotor(motoraddress: enMotorcolor, speed: number): void {\n        speed = speed / 2\n\n        let speed_Buff\n\n        if (speed < 0) {\n\n            speed = -speed\n\n            speed_Buff = (~speed) + 1\n\n            speed_Buff = speed_Buff | 0x80\n\n        }\n\n        else {\n\n            speed_Buff = speed\n\n        }\n\n        let SetBuff = pins.createBuffer(4)\n\n        SetBuff.setNumber(NumberFormat.UInt8BE, 0, 0x11)\n\n        SetBuff.setNumber(NumberFormat.UInt8BE, 1, speed_Buff)\n\n        SetBuff.setNumber(NumberFormat.UInt8BE, 2, 0)\n\n        SetBuff.setNumber(NumberFormat.UInt8BE, 3, 0)\n\n        pins.i2cWriteBuffer(motoraddress, SetBuff)\n\n\n    }\n    //% blockId=\"writemotorlocation\" block=\"|%motoraddress|Motor is turned at|%speed|to|%location|degrees\"\n\n    //% speed.min=0 speed.max=100\n\n    //% location.min=-360 location.max=360\n\n    //% parts=\"writemotorlocation\" subcategory=Movement group=\"Servo Motor\"\n\n    export function Writemotorlocation(motoraddress: enMotorcolor, speed: number, location: number): void {\n        if (speed == 0) {\n            return\n        }\n\n        speed = speed / 2\n        let speed_Buff2\n\n        if (speed < 0) {\n            speed = -speed\n            speed_Buff2 = (~speed) + 1\n            speed_Buff2 = speed_Buff2 | 0x80\n        }\n        else {\n            speed_Buff2 = speed\n        }\n\n        let location_Buff2\n\n        if (location < 0) {\n            location = -location\n            location_Buff2 = (~location) + 1\n            location_Buff2 = location_Buff2 | 0x8000\n        }\n        else {\n            location_Buff2 = location\n        }\n\n        let GetBuff3 = pins.createBuffer(6)\n        GetBuff3 = pins.i2cReadBuffer(motoraddress, 6)\n\n        if (((location - 5) <= getMotorLocation(GetBuff3)) && (getMotorLocation(GetBuff3) <= (location + 5))) {\n            return;\n        }\n        let SetBuff2 = pins.createBuffer(4)\n\n        SetBuff2.setNumber(NumberFormat.UInt8BE, 0, 0x3)\n        SetBuff2.setNumber(NumberFormat.UInt8BE, 1, speed_Buff2)\n        SetBuff2.setNumber(NumberFormat.UInt8BE, 2, location_Buff2 >> 8)\n        SetBuff2.setNumber(NumberFormat.UInt8BE, 3, location_Buff2)\n\n\n        pins.i2cWriteBuffer(motoraddress, SetBuff2)\n\n        let flag2 = GetBuff3.getNumber(NumberFormat.Int8BE, 5);\n        while (true) {//如果没有在运行，则一直读取\n            GetBuff3 = pins.i2cReadBuffer(motoraddress, 6)\n            flag2 = GetBuff3.getNumber(NumberFormat.Int8BE, 5)\n            if ((flag2 == 3)) break;//当有一个Servo Motor转动起来的时候，就退出死循环\n        }\n        while (true) {//如果没有在运行，则一直读取\n            GetBuff3 = pins.i2cReadBuffer(motoraddress, 6)\n            flag2 = GetBuff3.getNumber(NumberFormat.Int8BE, 5)\n            if ((flag2 == 11) || (flag2 == 10)) break;//当结束任务的时候，就退出死循环\n        }\n    }\n\n    //% blockId=\"writemotorrelativelocation\" block=\"|%motoraddress|Motor rotate at|%speed|in|%location|degrees\"\n\n    //% speed.min=-100 speed.max=100\n    //% location.min=0 \n    //% parts=\"writemotorrelativelocation\" subcategory=Movement group=\"Servo Motor\"\n\n    export function Writemotorrelativelocation(motoraddress: enMotorcolor, speed: number, location: number): void {\n        if (((location <= 5) && (location >= 0)) || ((location >= -5) && (location <= 0))) {\n            return;\n        }\n        speed = speed / 2\n\n        let location_Buff22\n\n        if (speed < 0) {\n            speed = -speed\n            location_Buff22 = (~location) + 1\n            location_Buff22 = location_Buff22 | 0x8000\n        }\n        else {\n            speed = speed\n            location_Buff22 = location\n        }\n\n        let SetBuff22 = pins.createBuffer(4)\n\n        SetBuff22.setNumber(NumberFormat.UInt8BE, 0, 0x4)\n        SetBuff22.setNumber(NumberFormat.UInt8BE, 1, speed)\n        SetBuff22.setNumber(NumberFormat.UInt8BE, 2, location_Buff22 >> 8)\n        SetBuff22.setNumber(NumberFormat.UInt8BE, 3, location_Buff22)\n\n        let GetBuff4 = pins.createBuffer(6)\n        let flag3 = 0\n\n        if (speed != 0) {\n            pins.i2cWriteBuffer(motoraddress, SetBuff22)\n        } else {\n            location = 0;\n        }\n\n\n        if (location != 0) {\n            while (true) {//如果没有在运行，则一直读取\n                GetBuff4 = pins.i2cReadBuffer(motoraddress, 6)\n                flag3 = GetBuff4.getNumber(NumberFormat.Int8BE, 5)\n                if ((flag3 == 4)) break;//等待电机执行指令，跳出循环\n            }\n            while (true) {//如果没有在运行，则一直读取\n                GetBuff4 = pins.i2cReadBuffer(motoraddress, 6)\n                flag3 = GetBuff4.getNumber(NumberFormat.Int8BE, 5)\n                if ((flag3 == 11) || (flag3 == 10)) break;//等待电机执行完指令或堵转时，跳出循环\n            }\n        }\n\n\n    }\n    //% blockId=\"writemotorrelativetime\" block=\"|%motoraddress|Motor rotate at|%speed|in|%time|seconds\"\n\n    //% speed.min=-100 speed.max=100\n\n    //% parts=\"writemotorrelativetime\" subcategory=Movement group=\"Servo Motor\"\n\n    export function Writemotorrelativetime(motoraddress: enMotorcolor, speed: number, time: number): void {\n\n        speed = speed / 2\n\n        if (time > 0 && time < 0.1) {\n            time = 0.1;\n        }\n        time = time * 10\n\n        let speed_Buff3\n\n        if (speed < 0) {\n            speed = -speed\n            speed_Buff3 = (~speed) + 1\n            speed_Buff3 = speed_Buff3 | 0x80\n        }\n        else {\n            speed_Buff3 = speed\n        }\n\n        let SetBuff222 = pins.createBuffer(4)\n\n        SetBuff222.setNumber(NumberFormat.UInt8BE, 0, 0x12)\n        SetBuff222.setNumber(NumberFormat.UInt8BE, 1, speed_Buff3)\n        SetBuff222.setNumber(NumberFormat.UInt8BE, 2, time >> 8)\n        SetBuff222.setNumber(NumberFormat.UInt8BE, 3, time)\n\n        let flag4 = 0\n        pins.i2cWriteBuffer(motoraddress, SetBuff222)\n\n        if (time != 0) {\n            if (speed <= 0) {\n                let waitFalg = (control.millis() + (time * 100));\n                while (control.millis() <= waitFalg) { }\n\n            } else {\n                let GetBuff5 = pins.createBuffer(6)\n                while (true) {//如果没有在运行，则一直读取\n                    GetBuff5 = pins.i2cReadBuffer(motoraddress, 6)\n                    flag4 = GetBuff5.getNumber(NumberFormat.Int8BE, 5)\n                    // serial.writeLine(\"read1:[\" + GetBuff.getNumber(NumberFormat.Int8BE, 0) + \",\" + GetBuff.getNumber(NumberFormat.Int8BE, 1) + \",\" + GetBuff.getNumber(NumberFormat.Int8BE, 2) + \",\" + GetBuff.getNumber(NumberFormat.Int8BE, 3) + \",\" + GetBuff.getNumber(NumberFormat.Int8BE, 4) + \",\" + GetBuff.getNumber(NumberFormat.Int8BE, 5) + \",\" + GetBuff.getNumber(NumberFormat.Int8BE, 6) + \"]\");\n                    if ((flag4 == 0x7)) break;//等待电机执行指令，跳出循环\n                }\n                while (true) {//如果没有在运行，则一直读取\n                    GetBuff5 = pins.i2cReadBuffer(motoraddress, 6)\n                    flag4 = GetBuff5.getNumber(NumberFormat.Int8BE, 5)\n                    // serial.writeLine(\"read2:\" + flag);\n                    if ((flag4 == 11)) break;//等待电机执行完指令或堵转时，跳出循环\n                }\n            }\n        }\n    }\n\n    //% blockId=SuperBit_runDMotor block=\"Dual motors rotate at|%speed1| |%speed2|\"\n\n    //% speed1.min=-100 speed1.max=100\n\n    //% speed2.min=-100 speed2.max=100\n\n    //% parts=\"SuperBit_runDMotor\" subcategory=Movement group=\"Servo Motor\"\n\n    export function runDMotor(speed1: number, speed2: number): void {\n\n        speed1 = -speed1 / 2\n        speed2 = speed2 / 2\n\n        let speed_Buff1\n        if (speed1 < 0) {\n            speed1 = -speed1\n            speed_Buff1 = (~speed1) + 1\n            speed_Buff1 = speed_Buff1 | 0x80\n        }\n        else {\n            speed_Buff1 = speed1\n        }\n\n        let speed_Buff23\n        if (speed2 < 0) {\n            speed2 = -speed2\n            speed_Buff23 = (~speed2) + 1\n            speed_Buff23 = speed_Buff23 | 0x80\n        }\n        else {\n            speed_Buff23 = speed2\n        }\n\n        let SetBuff3 = pins.createBuffer(4)\n        let SetBuffc = pins.createBuffer(4)\n\n\n        SetBuff3.setNumber(NumberFormat.UInt8BE, 0, 0x11)\n        SetBuff3.setNumber(NumberFormat.UInt8BE, 1, speed_Buff1)\n        SetBuff3.setNumber(NumberFormat.UInt8BE, 2, 0)\n        SetBuff3.setNumber(NumberFormat.UInt8BE, 3, 0)\n\n        SetBuffc.setNumber(NumberFormat.UInt8BE, 0, 0x11)\n        SetBuffc.setNumber(NumberFormat.UInt8BE, 1, speed_Buff23)\n        SetBuffc.setNumber(NumberFormat.UInt8BE, 2, 0)\n        SetBuffc.setNumber(NumberFormat.UInt8BE, 3, 0)\n\n        pins.i2cWriteBuffer(caraddress1, SetBuff3)\n        pins.i2cWriteBuffer(caraddress2, SetBuffc)\n\n    }\n    //% blockId=\"writeDmotorlocation\" block=\"Dual motors at|%speed1| |%speed2|in|%location|degrees\"\n\n    //% speed1.min=-100 speed1.max=100\n\n    //% speed2.min=-100 speed2.max=100\n    //% location.min=0 \n    //% parts=\"writeDmotorlocation\" subcategory=Movement group=\"Servo Motor\"\n\n    export function WriteDmotorlocation(speed1: number, speed2: number, location: number): void {\n        if (((location <= 5) && (location >= 0)) || ((location >= -5) && (location <= 0))) {\n            return;\n        }\n        speed1 = -speed1 / 2\n        speed2 = speed2 / 2\n\n        let location1\n        let location_Buff1\n\n        let location2\n        let location_Buff23\n\n        location2 = ~location\n        location1 = ~location\n\n        if (speed2 < 0) {\n            speed2 = -speed2\n            location_Buff23 = location2 + 1\n        }\n        else {\n            location_Buff23 = location\n        }\n\n        if (speed1 < 0) {\n            speed1 = -speed1\n            location_Buff1 = location1 + 1\n        }\n        else {\n            location_Buff1 = location\n        }\n\n        if (speed1 == 0) {\n            location_Buff1 = 0\n        }\n\n        if (speed2 == 0) {\n            location_Buff23 = 0\n        }\n\n        let SetBuff23 = pins.createBuffer(4)\n        let SetBuff2c = pins.createBuffer(4)\n\n\n        SetBuff2c.setNumber(NumberFormat.UInt8BE, 0, 0x4)\n        SetBuff2c.setNumber(NumberFormat.UInt8BE, 1, speed2)\n        SetBuff2c.setNumber(NumberFormat.UInt8BE, 2, location_Buff23 >> 8)\n        SetBuff2c.setNumber(NumberFormat.UInt8BE, 3, location_Buff23)\n\n\n        SetBuff23.setNumber(NumberFormat.UInt8BE, 0, 0x4)\n        SetBuff23.setNumber(NumberFormat.UInt8BE, 1, speed1)\n        SetBuff23.setNumber(NumberFormat.UInt8BE, 2, location_Buff1 >> 8)\n        SetBuff23.setNumber(NumberFormat.UInt8BE, 3, location_Buff1)\n\n        if ((location != 0) && ((speed1 != 0) || (speed2 != 0))) {\n\n\n            let GetBuff6 = pins.createBuffer(7)\n            let GetBuff1 = pins.createBuffer(7)\n\n            //发送控制参数并获取运动状态\n            pins.i2cWriteBuffer(caraddress1, SetBuff23)\n            GetBuff1 = pins.i2cReadBuffer(caraddress1, 6)\n            pins.i2cWriteBuffer(caraddress2, SetBuff2c)\n            GetBuff6 = pins.i2cReadBuffer(caraddress2, 6)\n\n            let flag5 = GetBuff6.getNumber(NumberFormat.Int8BE, 5)//获取了第6位\n            let flag1 = GetBuff1.getNumber(NumberFormat.Int8BE, 5)//获取了第6位\n            //4为正在运行\n            while (true) {//如果没有在运行，则一直读取\n\n                GetBuff6 = pins.i2cReadBuffer(caraddress2, 6)\n                GetBuff1 = pins.i2cReadBuffer(caraddress1, 6)\n                flag5 = GetBuff6.getNumber(NumberFormat.Int8BE, 5)\n                flag1 = GetBuff1.getNumber(NumberFormat.Int8BE, 5)\n                if ((flag1 == 4) || (flag5 == 4)) break;//当有一个电机转动起来的时候，就退出死循环\n\n\n            }\n            //11为运行结束\n            while (true) {\n                GetBuff6 = pins.i2cReadBuffer(caraddress2, 6)\n                GetBuff1 = pins.i2cReadBuffer(caraddress1, 6)\n                flag5 = GetBuff6.getNumber(NumberFormat.Int8BE, 5)\n                flag1 = GetBuff1.getNumber(NumberFormat.Int8BE, 5)\n                // 11：结束运动，10：堵转停止\n                if (((flag1 == 11) || (flag1 == 10)) && ((flag5 == 11) || (flag5 == 10))) break;//当有两个电机都执行完毕的时候，就退出死循环\n            }\n        }\n    }\n\n    //% blockId=\"writeDmotortime\" block=\"Dual motors rotate at |%speed1| |%speed2|in|%time|seconds\"\n\n    //% speed1.min=-100 speed1.max=100\n\n    //% speed2.min=-100 speed2.max=100\n    //% time.min=0 \n    //% parts=\"writeDmotortime\" subcategory=Movement group=\"Servo Motor\"\n\n    export function writeDmotortime(speed1: number, speed2: number, time: number): void {\n\n        speed1 = -speed1 / 2\n        speed2 = speed2 / 2\n        // serial.writeLine(\"read1:\" + time + \",\" + (time > 0 && time < 0.1));\n        if (time > 0 && time < 0.1) {\n            time = 0.1;\n        }\n        time = time * 10\n        let speed_Buff32\n        let speed_Buff4\n\n        if (speed1 < 0) {\n            speed1 = -speed1\n            speed_Buff32 = (~speed1) + 1\n            speed_Buff32 = speed_Buff32 | 0x80\n        }\n        else {\n            speed_Buff32 = speed1\n        }\n\n        if (speed2 < 0) {\n            speed2 = -speed2\n            speed_Buff4 = (~speed2) + 1\n            speed_Buff4 = speed_Buff4 | 0x80\n        }\n        else {\n            speed_Buff4 = speed2\n        }\n\n        let SetBuff32 = pins.createBuffer(4)\n        let SetBuff4 = pins.createBuffer(4)\n\n        SetBuff32.setNumber(NumberFormat.UInt8BE, 0, 0x12)\n        SetBuff32.setNumber(NumberFormat.UInt8BE, 1, speed_Buff32)\n        SetBuff32.setNumber(NumberFormat.UInt8BE, 2, time >> 8)\n        SetBuff32.setNumber(NumberFormat.UInt8BE, 3, time)\n\n        SetBuff4.setNumber(NumberFormat.UInt8BE, 0, 0x12)\n        SetBuff4.setNumber(NumberFormat.UInt8BE, 1, speed_Buff4)\n        SetBuff4.setNumber(NumberFormat.UInt8BE, 2, time >> 8)\n        SetBuff4.setNumber(NumberFormat.UInt8BE, 3, time)\n        // serial.writeLine(\"read1:\" + SetBuff4.getNumber(NumberFormat.UInt8BE, ));\n\n        if (speed1 != 0) {\n            pins.i2cWriteBuffer(caraddress1, SetBuff32)\n        }\n        if (speed2 != 0) {\n            pins.i2cWriteBuffer(caraddress2, SetBuff4)\n        }\n\n\n\n        if ((time !== 0) && ((speed1 !== 0) || (speed2 !== 0))) {\n            let GetBuff7 = pins.createBuffer(6)\n            let GetBuff12 = pins.createBuffer(6)\n\n            GetBuff7 = pins.i2cReadBuffer(caraddress2, 6)\n            GetBuff12 = pins.i2cReadBuffer(caraddress1, 6)\n\n            let flag6 = GetBuff7.getNumber(NumberFormat.Int8BE, 5)//获取了第6位\n            let flag12 = GetBuff12.getNumber(NumberFormat.Int8BE, 5)//获取了第6位\n\n            while (true) {//如果没有在运行，则一直读取\n\n                GetBuff7 = pins.i2cReadBuffer(caraddress2, 6)\n                GetBuff12 = pins.i2cReadBuffer(caraddress1, 6)\n                flag6 = GetBuff7.getNumber(NumberFormat.Int8BE, 5)\n                flag12 = GetBuff12.getNumber(NumberFormat.Int8BE, 5)\n                // serial.writeLine(\"read2:[\" + flag1 + \",\" + flag+\"]\");\n                if ((flag12 == 0x7) || (flag6 == 0x7)) break;//当有一个电机转动起来的时候，就退出死循环\n\n\n            }\n            //11为运行结束\n            while (true) {\n                GetBuff7 = pins.i2cReadBuffer(caraddress2, 6)\n                GetBuff12 = pins.i2cReadBuffer(caraddress1, 6)\n                flag6 = GetBuff7.getNumber(NumberFormat.Int8BE, 5)\n                flag12 = GetBuff12.getNumber(NumberFormat.Int8BE, 5)\n                // serial.writeLine(\"read3:[\" + flag1 + \",\" + flag + \"]\");\n                if (((flag12 == 11)) && ((flag6 == 11))) break;//当有两个电机都执行完毕的时候，就退出死循环\n\n            }\n        }\n\n    }\n\n    //% blockId=SuperBit_DMotor block=\"Set left motor to|%motoraddress1|and right motor to|%motoraddress2|\"\n\n    //% parts=\"SuperBit_DMotor\" subcategory=Movement group=\"Servo Motor\"\n\n    export function DMotor(motoraddress1: enMotorcolor, motoraddress2: enMotorcolor): void {\n        caraddress1 = motoraddress1\n\n        caraddress2 = motoraddress2\n\n    }\n\n\n    //% blockId=SuperBit_Servo4 block=\"Servo| %num|angle %value\"\n    //% num.min=1 num.max=4 value.min=0 value.max=300\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=20\n    //%  subcategory=Movement\n    export function Servo4(num: enServo, value: number): void {\n\n        // 50hz: 20,000 us\n        let us = (value * 1800 * 0.6 / 180 + 600); // 0.6 ~ 2.4\n        let pwm = us * 4096 / 20000;\n        setPwm(num, 0, pwm);\n\n    }\n\n    //% blockId=\"readmotorspeed\" block=\"Read speed of the |%motoraddress|motor\"\n\n    //% parts=\"readmotorspeed\" subcategory=Movement group=\"Servo Motor\"\n\n    export function Readmotorspeed(motoraddress: enMotorcolor): number {\n\n        let GetBuff8 = pins.createBuffer(6)\n        GetBuff8 = pins.i2cReadBuffer(motoraddress, 6)\n        return GetBuff8.getNumber(NumberFormat.Int8BE, 0);\n\n    }\n\n    function getMotorLocation(buffer: Buffer) {\n\n        let location_Buff = (buffer.getNumber(NumberFormat.Int8BE, 1) << 8) + buffer.getNumber(NumberFormat.Int8BE, 2)\n        let This_location;\n        if (location_Buff & 0x0080) {\n            This_location = location_Buff + 0x0100\n        }\n        else {\n            This_location = location_Buff\n        }\n        return This_location;\n    }\n    function getMotorSpeed(buffer: Buffer) {\n\n        let location_Buff3 = (buffer.getNumber(NumberFormat.Int8BE, 0) << 8) + buffer.getNumber(NumberFormat.Int8BE, 1)\n        let This_speed;\n        if (location_Buff3 & 0x0080) {\n            This_speed = location_Buff3 + 0x0100\n        }\n        else {\n            This_speed = location_Buff3\n        }\n        return This_speed;\n    }\n\n    //% blockId=\"readmotorlocation\" block=\"Read position of the |%motoraddress|motor\"\n\n    //% parts=\"readmotorlocation\" subcategory=Movement group=\"Servo Motor\"\n\n    export function Readmotorlocation(motoraddress: enMotorcolor): number {\n\n        let GetBuff22 = pins.createBuffer(6)\n\n        GetBuff22 = pins.i2cReadBuffer(motoraddress, 6)\n        let This_location2 = getMotorLocation(GetBuff22);\n        return This_location2;\n\n    }\n    \n\n\n\n\n    //% blockId=fans block=\"Fan %fanpin switch $fanstate || speed %speed\"\n\n    //% fanstate.shadow=\"toggleOnOff\"\n\n    //% weight=24\n\n    //% fanpin.fieldEditor=\"gridpicker\"\n\n    //% fanpin.fieldOptions.width=220\n\n    //% fanpin.fieldOptions.columns=1\n\n    //% speed.min=0 speed.max=1023\n\n    //% expandableArgumentMode=\"toggle\"\n\n    //% subcategory=Movement\n\n    export function motorFan(fanpin: Read_pin, fanstate: boolean, speed: number = 1023): void {\n\n        let pin3\n\n\n\n\n\n        if (fanpin == 1) {\n\n\n\n            pin3 = AnalogPin.P0;\n\n        }\n\n        if (fanpin == 2) {\n\n            pin3 = AnalogPin.P1;\n\n        }\n\n        if (fanpin == 3) {\n\n            pin3 = AnalogPin.P2;\n\n        }\n\n\n\n        if (fanstate) {\n\n            pins.analogSetPeriod(pin3, 1023);\n\n            pins.analogWritePin(pin3, Math.map(speed, 0, 1023, 0, 1023));\n\n        }\n\n        else {\n\n            pins.analogWritePin(pin3, 0);\n\n            speed = 0;\n\n        }\n\n\n\n    }\n\n\n\n    //% blockId=\"elecmagnet\" block=\"Electromagnet %elecpin switch %magState || electromagnet %force\"\n\n    //% magState.shadow=\"toggleOnOff\"\n\n    //% weight=23\n\n    //% elecpin.fieldEditor=\"gridpicker\"\n\n    //% elecpin.fieldOptions.width=220\n\n    //% elecpin.fieldOptions.columns=2\n\n    //% force.min=0 force.max=1023\n\n    //% expandableArgumentMode=\"toggle\"\n\n    //% subcategory=Movement\n\n    export function elecmagnet(elecpin: Write_pin, magState: boolean, force: number = 1023): void {\n\n        let pin8\n\n        if (elecpin == 1) {\n\n\n\n            pin8 = AnalogPin.P0;\n\n        }\n\n        if (elecpin == 2) {\n\n            pin8 = AnalogPin.P16;\n\n        }\n\n        if (elecpin == 3) {\n\n            pin8 = AnalogPin.P1;\n\n        }\n\n        if (elecpin == 4) {\n\n\n\n            pin8 = AnalogPin.P12;\n\n        }\n\n        if (elecpin == 5) {\n\n            pin8 = AnalogPin.P2;\n\n        }\n\n        if (elecpin == 6) {\n\n            pin8 = AnalogPin.P8;\n\n        }\n\n\n\n        if (magState == true) {\n\n            pins.analogSetPeriod(pin8, 1023)\n\n            pins.analogWritePin(pin8, Math.map(force, 0, 1023, 0, 1023))\n\n        }\n\n        else {\n\n            pins.analogWritePin(pin8, 0)\n\n            force = 0\n\n        }\n\n    }\n\n\n\n    ////////////////////////////////////////////\n\n\n\n\n    //% blockId=LEDR block=\"Red LED %pin swicth $ledstate \"\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=2\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=\"Audio-visual\" group=\"LED\"\n    export function ledRBrightness(pin: Write_pin, ledstate: boolean): void {\n        let myPin; // 直接将 pin 赋值给 myPin\n\n        switch (pin) {\n            case 1:\n                myPin = DigitalPin.P0;\n                break;\n            case 2:\n                myPin = DigitalPin.P16;\n                break;\n            case 3:\n                myPin = DigitalPin.P1;\n                break;\n            case 4:\n                myPin = DigitalPin.P12;\n                break;\n            case 5:\n                myPin = DigitalPin.P2;\n                break;\n            case 6:\n                myPin = DigitalPin.P8;\n                break;\n        }\n        if (ledstate) {\n            pins.digitalWritePin(myPin, 0)\n        }\n        else {\n            pins.digitalWritePin(myPin, 1)\n        }\n    }\n\n\n\n    //% blockId=LEDG block=\"Green LED %pin switch $ledstate \"\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=2\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=\"Audio-visual\" group=\"LED\"\n    export function ledGBrightness(pin: Write_pin, ledstate: boolean): void {\n        let myPin2; // 直接将 pin 赋值给 myPin\n\n        switch (pin) {\n            case 1:\n                myPin2 = DigitalPin.P0;\n                break;\n            case 2:\n                myPin2 = DigitalPin.P16;\n                break;\n            case 3:\n                myPin2 = DigitalPin.P1;\n                break;\n            case 4:\n                myPin2 = DigitalPin.P12;\n                break;\n            case 5:\n                myPin2 = DigitalPin.P2;\n                break;\n            case 6:\n                myPin2 = DigitalPin.P8;\n                break;\n        }\n\n        if (ledstate) {\n            pins.digitalWritePin(myPin2, 0)\n        }\n        else {\n            pins.digitalWritePin(myPin2, 1)\n        }\n    }\n\n\n    //% blockId=LEDB block=\"Blue LED %pin switch $ledstate \"\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=2\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=\"Audio-visual\" group=\"LED\"\n    export function ledBBrightness(pin: Write_pin, ledstate: boolean): void {\n        let myPin3; // 直接将 pin 赋值给 myPin\n\n        switch (pin) {\n            case 1:\n                myPin3 = DigitalPin.P0;\n                break;\n            case 2:\n                myPin3 = DigitalPin.P16;\n                break;\n            case 3:\n                myPin3 = DigitalPin.P1;\n                break;\n            case 4:\n                myPin3 = DigitalPin.P12;\n                break;\n            case 5:\n                myPin3 = DigitalPin.P2;\n                break;\n            case 6:\n                myPin3 = DigitalPin.P8;\n                break;\n        }\n        if (ledstate) {\n            pins.digitalWritePin(myPin3, 0)\n        }\n        else {\n            pins.digitalWritePin(myPin3, 1)\n        }\n    }\n\n\n    //% blockId=LEDY block=\"Yellow LED %pin swicth $ledstate \"\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=2\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=\"Audio-visual\" group=\"LED\"\n    export function ledYBrightness(pin: Write_pin, ledstate: boolean): void {\n        let myPin4; // 直接将 pin 赋值给 myPin\n\n        switch (pin) {\n            case 1:\n                myPin4 = DigitalPin.P0;\n                break;\n            case 2:\n                myPin4 = DigitalPin.P16;\n                break;\n            case 3:\n                myPin4 = DigitalPin.P1;\n                break;\n            case 4:\n                myPin4 = DigitalPin.P12;\n                break;\n            case 5:\n                myPin4 = DigitalPin.P2;\n                break;\n            case 6:\n                myPin4 = DigitalPin.P8;\n                break;\n        }\n\n        if (ledstate) {\n            pins.digitalWritePin(myPin4, 0)\n        }\n        else {\n            pins.digitalWritePin(myPin4, 1)\n        }\n    }\n\n\n\n\n\n\n\n\n\n    enum LCS_Constants {\n\n        // Constants\n\n        ADDRESS = 0x29,\n\n        ID = 0x12, // Register should be equal to 0x44 for the TCS34721 or TCS34725, or 0x4D for the TCS34723 or TCS34727.\n\n\n\n        COMMAND_BIT = 0x80,\n\n\n\n        ENABLE = 0x00,\n\n        ENABLE_AIEN = 0x10, // RGBC Interrupt Enable\n\n        ENABLE_WEN = 0x08, // Wait enable - Writing 1 activates the wait timer\n\n        ENABLE_AEN = 0x02, // RGBC Enable - Writing 1 actives the ADC, 0 disables it\n\n        ENABLE_PON = 0x01, // Power on - Writing 1 activates the internal oscillator, 0 disables it\n\n        ATIME = 0x01, // Integration time\n\n        WTIME = 0x03, // Wait time (if ENABLE_WEN is asserted)\n\n        AILTL = 0x04, // Clear channel lower interrupt threshold\n\n        AILTH = 0x05,\n\n        AIHTL = 0x06, // Clear channel upper interrupt threshold\n\n        AIHTH = 0x07,\n\n        PERS = 0x0C, // Persistence register - basic SW filtering mechanism for interrupts\n\n        PERS_NONE = 0x00, // Every RGBC cycle generates an interrupt\n\n        PERS_1_CYCLE = 0x01, // 1 clean channel value outside threshold range generates an interrupt\n\n        PERS_2_CYCLE = 0x02, // 2 clean channel values outside threshold range generates an interrupt\n\n        PERS_3_CYCLE = 0x03, // 3 clean channel values outside threshold range generates an interrupt\n\n        PERS_5_CYCLE = 0x04, // 5 clean channel values outside threshold range generates an interrupt\n\n        PERS_10_CYCLE = 0x05, // 10 clean channel values outside threshold range generates an interrupt\n\n        PERS_15_CYCLE = 0x06, // 15 clean channel values outside threshold range generates an interrupt\n\n        PERS_20_CYCLE = 0x07, // 20 clean channel values outside threshold range generates an interrupt\n\n        PERS_25_CYCLE = 0x08, // 25 clean channel values outside threshold range generates an interrupt\n\n        PERS_30_CYCLE = 0x09, // 30 clean channel values outside threshold range generates an interrupt\n\n        PERS_35_CYCLE = 0x0A, // 35 clean channel values outside threshold range generates an interrupt\n\n        PERS_40_CYCLE = 0x0B, // 40 clean channel values outside threshold range generates an interrupt\n\n        PERS_45_CYCLE = 0x0C, // 45 clean channel values outside threshold range generates an interrupt\n\n        PERS_50_CYCLE = 0x0D, // 50 clean channel values outside threshold range generates an interrupt\n\n        PERS_55_CYCLE = 0x0E, // 55 clean channel values outside threshold range generates an interrupt\n\n        PERS_60_CYCLE = 0x0F, // 60 clean channel values outside threshold range generates an interrupt\n\n        CONFIG = 0x0D,\n\n        CONFIG_WLONG = 0x02, // Choose between short and long (12x) wait times via WTIME\n\n        CONTROL = 0x0F, // Set the gain level for the sensor\n\n        STATUS = 0x13,\n\n        STATUS_AINT = 0x10, // RGBC Clean channel interrupt\n\n        STATUS_AVALID = 0x01, // Indicates that the RGBC channels have completed an integration cycle\n\n\n\n        CDATAL = 0x14, // Clear channel data\n\n        CDATAH = 0x15,\n\n        RDATAL = 0x16, // Red channel data\n\n        RDATAH = 0x17,\n\n        GDATAL = 0x18, // Green channel data\n\n        GDATAH = 0x19,\n\n        BDATAL = 0x1A, // Blue channel data\n\n        BDATAH = 0x1B,\n\n\n\n        GAIN_1X = 0x00, //  1x gain\n\n        GAIN_4X = 0x01, //  4x gain\n\n        GAIN_16X = 0x02, // 16x gain\n\n        GAIN_60X = 0x03  // 60x gain\n\n    }\n\n\n\n    let LCS_integration_time_val = 0\n\n\n\n    // I2C functions\n\n\n\n    function I2C_WriteReg8(addr: number, reg: number, val: number) {\n\n        let buf32 = pins.createBuffer(2)\n\n        buf32.setNumber(NumberFormat.UInt8BE, 0, reg)\n\n        buf32.setNumber(NumberFormat.UInt8BE, 1, val)\n\n        pins.i2cWriteBuffer(addr, buf32)\n\n    }\n\n\n\n    function I2C_ReadReg8(addr: number, reg: number): number {\n\n        let buf42 = pins.createBuffer(1)\n\n        buf42.setNumber(NumberFormat.UInt8BE, 0, reg)\n\n        pins.i2cWriteBuffer(addr, buf42)\n\n        buf42 = pins.i2cReadBuffer(addr, 1)\n\n        return buf42.getNumber(NumberFormat.UInt8BE, 0);\n\n    }\n\n\n\n    function I2C_ReadReg16(addr: number, reg: number): number {\n\n        let buf52 = pins.createBuffer(1)\n\n        buf52.setNumber(NumberFormat.UInt8BE, 0, reg)\n\n        pins.i2cWriteBuffer(addr, buf52)\n\n        buf52 = pins.i2cReadBuffer(addr, 2)\n\n        // Little endian\n\n        return ((buf52.getNumber(NumberFormat.UInt8BE, 1) << 8) | buf52.getNumber(NumberFormat.UInt8BE, 0));\n\n    }\n\n    function LCS_get_raw_data(delay: boolean = false): number[] {\n\n        if (delay) {\n\n            // Delay for the integration time to allow reading immediately after the previous read.\n\n            basic.pause((256 - LCS_integration_time_val) * 2.4)\n\n        }\n\n\n\n        let div = (256 - LCS_integration_time_val) * 1024\n\n        let rgbc = [0, 0, 0, 0]\n\n        rgbc[0] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.RDATAL)) / div\n\n        rgbc[1] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.GDATAL)) / div\n\n        rgbc[2] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.BDATAL)) / div\n\n        rgbc[3] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CDATAL)) / div\n\n        if (rgbc[0] > 1) {\n\n            rgbc[0] = 1\n\n        }\n\n        if (rgbc[1] > 1) {\n\n            rgbc[1] = 1\n\n        }\n\n        if (rgbc[2] > 1) {\n\n            rgbc[2] = 1\n\n        }\n\n        if (rgbc[3] > 1) {\n\n            rgbc[3] = 1\n\n        }\n\n        return rgbc\n\n    }\n\n\n\n    let font: number[] = [];\n\n    font[0] = 0x0022d422;\n\n    font[1] = 0x0022d422;\n\n    font[2] = 0x0022d422;\n\n    font[3] = 0x0022d422;\n\n    font[4] = 0x0022d422;\n\n    font[5] = 0x0022d422;\n\n    font[6] = 0x0022d422;\n\n    font[7] = 0x0022d422;\n\n    font[8] = 0x0022d422;\n\n    font[9] = 0x0022d422;\n\n    font[10] = 0x0022d422;\n\n    font[11] = 0x0022d422;\n\n    font[12] = 0x0022d422;\n\n    font[13] = 0x0022d422;\n\n    font[14] = 0x0022d422;\n\n    font[15] = 0x0022d422;\n\n    font[16] = 0x0022d422;\n\n    font[17] = 0x0022d422;\n\n    font[18] = 0x0022d422;\n\n    font[19] = 0x0022d422;\n\n    font[20] = 0x0022d422;\n\n    font[21] = 0x0022d422;\n\n    font[22] = 0x0022d422;\n\n    font[23] = 0x0022d422;\n\n    font[24] = 0x0022d422;\n\n    font[25] = 0x0022d422;\n\n    font[26] = 0x0022d422;\n\n    font[27] = 0x0022d422;\n\n    font[28] = 0x0022d422;\n\n    font[29] = 0x0022d422;\n\n    font[30] = 0x0022d422;\n\n    font[31] = 0x0022d422;\n\n    font[32] = 0x00000000;\n\n    font[33] = 0x000002e0;\n\n    font[34] = 0x00018060;\n\n    font[35] = 0x00afabea;\n\n    font[36] = 0x00aed6ea;\n\n    font[37] = 0x01991133;\n\n    font[38] = 0x010556aa;\n\n    font[39] = 0x00000060;\n\n    font[40] = 0x000045c0;\n\n    font[41] = 0x00003a20;\n\n    font[42] = 0x00051140;\n\n    font[43] = 0x00023880;\n\n    font[44] = 0x00002200;\n\n    font[45] = 0x00021080;\n\n    font[46] = 0x00000100;\n\n    font[47] = 0x00111110;\n\n    font[48] = 0x0007462e;\n\n    font[49] = 0x00087e40;\n\n    font[50] = 0x000956b9;\n\n    font[51] = 0x0005d629;\n\n    font[52] = 0x008fa54c;\n\n    font[53] = 0x009ad6b7;\n\n    font[54] = 0x008ada88;\n\n    font[55] = 0x00119531;\n\n    font[56] = 0x00aad6aa;\n\n    font[57] = 0x0022b6a2;\n\n    font[58] = 0x00000140;\n\n    font[59] = 0x00002a00;\n\n    font[60] = 0x0008a880;\n\n    font[61] = 0x00052940;\n\n    font[62] = 0x00022a20;\n\n    font[63] = 0x0022d422;\n\n    font[64] = 0x00e4d62e;\n\n    font[65] = 0x000f14be;\n\n    font[66] = 0x000556bf;\n\n    font[67] = 0x0008c62e;\n\n    font[68] = 0x0007463f;\n\n    font[69] = 0x0008d6bf;\n\n    font[70] = 0x000094bf;\n\n    font[71] = 0x00cac62e;\n\n    font[72] = 0x000f909f;\n\n    font[73] = 0x000047f1;\n\n    font[74] = 0x0017c629;\n\n    font[75] = 0x0008a89f;\n\n    font[76] = 0x0008421f;\n\n    font[77] = 0x01f1105f;\n\n    font[78] = 0x01f4105f;\n\n    font[79] = 0x0007462e;\n\n    font[80] = 0x000114bf;\n\n    font[81] = 0x000b6526;\n\n    font[82] = 0x010514bf;\n\n    font[83] = 0x0004d6b2;\n\n    font[84] = 0x0010fc21;\n\n    font[85] = 0x0007c20f;\n\n    font[86] = 0x00744107;\n\n    font[87] = 0x01f4111f;\n\n    font[88] = 0x000d909b;\n\n    font[89] = 0x00117041;\n\n    font[90] = 0x0008ceb9;\n\n    font[91] = 0x0008c7e0;\n\n    font[92] = 0x01041041;\n\n    font[93] = 0x000fc620;\n\n    font[94] = 0x00010440;\n\n    font[95] = 0x01084210;\n\n    font[96] = 0x00000820;\n\n    font[97] = 0x010f4a4c;\n\n    font[98] = 0x0004529f;\n\n    font[99] = 0x00094a4c;\n\n    font[100] = 0x000fd288;\n\n    font[101] = 0x000956ae;\n\n    font[102] = 0x000097c4;\n\n    font[103] = 0x0007d6a2;\n\n    font[104] = 0x000c109f;\n\n    font[105] = 0x000003a0;\n\n    font[106] = 0x0006c200;\n\n    font[107] = 0x0008289f;\n\n    font[108] = 0x000841e0;\n\n    font[109] = 0x01e1105e;\n\n    font[110] = 0x000e085e;\n\n    font[111] = 0x00064a4c;\n\n    font[112] = 0x0002295e;\n\n    font[113] = 0x000f2944;\n\n    font[114] = 0x0001085c;\n\n    font[115] = 0x00012a90;\n\n    font[116] = 0x010a51e0;\n\n    font[117] = 0x010f420e;\n\n    font[118] = 0x00644106;\n\n    font[119] = 0x01e8221e;\n\n    font[120] = 0x00093192;\n\n    font[121] = 0x00222292;\n\n    font[122] = 0x00095b52;\n\n    font[123] = 0x0008fc80;\n\n    font[124] = 0x000003e0;\n\n    font[125] = 0x000013f1;\n\n    font[126] = 0x00841080;\n\n    font[127] = 0x0022d422;\n\n\n\n    let _I2CAddr = 0;\n\n    let _screen = pins.createBuffer(1025);\n\n    let _buf2 = pins.createBuffer(2);\n\n    let _buf3 = pins.createBuffer(3);\n\n    let _buf4 = pins.createBuffer(4);\n\n    let _ZOOM = 1;\n\n\n\n    function cmd1(d: number) {\n\n        let n = d % 256;\n\n        pins.i2cWriteNumber(_I2CAddr, n, NumberFormat.UInt16BE);\n\n    }\n\n\n\n    function cmd2(d1: number, d2: number) {\n\n        _buf3[0] = 0;\n\n        _buf3[1] = d1;\n\n        _buf3[2] = d2;\n\n        pins.i2cWriteBuffer(_I2CAddr, _buf3);\n\n    }\n\n\n\n    function cmd3(d1: number, d2: number, d3: number) {\n\n        _buf4[0] = 0;\n\n        _buf4[1] = d1;\n\n        _buf4[2] = d2;\n\n        _buf4[3] = d3;\n\n        pins.i2cWriteBuffer(_I2CAddr, _buf4);\n\n    }\n\n\n\n    function set_pos(col: number = 0, page: number = 0) {\n\n        cmd1(0xb0 | page) // page number\n\n        let c = col * (_ZOOM + 1)\n\n        cmd1(0x00 | (c % 16)) // lower start column address\n\n        cmd1(0x10 | (c >> 4)) // upper start column address    \n\n    }\n\n\n\n    // clear bit\n\n    function clrbit(d: number, b: number): number {\n\n        if (d & (1 << b))\n\n            d -= (1 << b)\n\n        return d\n\n    }\n\n\n\n\n\n\n\n\n    /**\n\n     * A NeoPixel strip\n\n     */\n\n    export class Strip {\n\n        buf: Buffer;\n\n        lastrgb: number;\n\n        pin: DigitalPin;\n\n        // TODO: encode as bytes instead of 32bit\n\n        brightness: number;\n\n        start: number; // start offset in LED strip\n\n        _length: number; // number of LEDs\n\n        _mode: NeoPixelMode;\n\n        _matrixWidth: number; // number of leds in a matrix - if any\n\n\n\n        /**\n\n         * Shows all LEDs to a given color (range 0-255 for r, g, b).\n\n         * @param rgb RGB color of the LED\n\n         */\n\n        //% blockId=\"neopixel_set_strip_color\" block=\"%strip|display Color %rgb=neopixel_colors\"\n\n        //% strip.defl=strip\n\n        //% weight=12\n\n        //% parts=\"neopixel\" subcategory=\"Audio-visual\" group=\"RGB LED Module\"\n\n        //% color=#2699BF blockGap=10\n\n        showColor(rgb: number) {\n\n            rgb = rgb >> 0;\n\n            this.lastrgb = rgb;\n\n            this.setAllRGB(rgb);\n\n            this.show();\n\n        }\n\n\n\n        /**\n\n         * Shows a rainbow pattern on all LEDs.\n\n         * @param startHue the start hue value for the rainbow, eg: 1\n\n         * @param endHue the end hue value for the rainbow, eg: 360\n\n         */\n\n        //% blockId=\"neopixel_set_strip_rainbow\" block=\"%strip|Display rainbow from start %startHue|to %endHue\"\n\n        //% strip.defl=strip\n\n        //% weight=13\n\n        //% parts=\"neopixel\" subcategory=\"Audio-visual\" group=\"RGB LED Module\"\n\n        //% color=#2699BF blockGap=10\n\n        showRainbow(startHue: number = 1, endHue: number = 360) {\n\n            if (this._length <= 0) return;\n\n\n\n            startHue = startHue >> 0;\n\n            endHue = endHue >> 0;\n\n            const saturation = 100;\n\n            const luminance = 50;\n\n            const steps = this._length + 1;\n\n            const direction = HueInterpolationDirection.Clockwise;\n\n\n\n            //hue\n\n            const h1 = startHue;\n\n            const h2 = endHue;\n\n            const hDistCW = ((h2 + 360) - h1) % 360;\n\n            const hStepCW = Math.idiv((hDistCW * 100), steps);\n\n            const hDistCCW = ((h1 + 360) - h2) % 360;\n\n            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\n\n            let hStep: number;\n\n            if (direction === HueInterpolationDirection.Clockwise) {\n\n                hStep = hStepCW;\n\n            } else if (direction === HueInterpolationDirection.CounterClockwise) {\n\n                hStep = hStepCCW;\n\n            } else {\n\n                hStep = hDistCW < hDistCCW ? hStepCW : hStepCCW;\n\n            }\n\n            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n\n\n\n            //sat\n\n            const s1 = saturation;\n\n            const s2 = saturation;\n\n            const sDist = s2 - s1;\n\n            const sStep = Math.idiv(sDist, steps);\n\n            const s1_100 = s1 * 100;\n\n\n\n            //lum\n\n            const l1 = luminance;\n\n            const l2 = luminance;\n\n            const lDist = l2 - l1;\n\n            const lStep = Math.idiv(lDist, steps);\n\n            const l1_100 = l1 * 100\n\n\n\n            //interpolate\n\n            if (steps === 1) {\n\n                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\n\n            } else {\n\n                this.setPixelColor(0, hsl(startHue, saturation, luminance));\n\n                for (let t = 1; t < steps - 1; t++) {\n\n                    const u = Math.idiv((h1_100 + t * hStep), 100) + 360;\n\n                    const v = Math.idiv((s1_100 + t * sStep), 100);\n\n                    const w = Math.idiv((l1_100 + t * lStep), 100);\n\n                    this.setPixelColor(t, hsl(u, v, w));\n\n                }\n\n                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\n\n            }\n\n            this.show();\n\n        }\n\n\n\n\n\n\n        setPixelColor(pixeloffset: number, rgb: number): void {\n\n            this.setPixelRGB((pixeloffset - 1) >> 0, rgb >> 0);\n\n        }\n\n\n\n\n\n        \n\n\n\n        /**\n    \n         * Set the brightness of the strip. This flag only applies to future operation.\n    \n         * @param brightness a measure of LED brightness in 0-255. eg: 255\n    \n         */\n\n        //% blockId=\"neopixel_set_brightness\" block=\"%strip|set brightness %brightness\"\n\n        //% strip.defl=strip\n\n        //% weight=17\n\n        //% parts=\"neopixel\" subcategory=\"Audio-visual\" group=\"RGB LED Module\"\n\n        //% color=#2699BF blockGap=10\n\n        setBrightness(brightness: number): void {\n\n            this.brightness = brightness & 0xff;\n\n            this.setAllRGB(this.lastrgb);\n\n            this.show();\n\n        }\n\n        show() {\n\n            // only supported in beta\n\n            // ws2812b.setBufferMode(this.pin, this._mode);\n\n            ws2812b.sendBuffer(this.buf, this.pin);\n\n        }\n\n\n        /**\n    \n         * Set the pin where the neopixel is connected, defaults to P0.\n    \n         */\n\n        //% parts=\"neopixel\" subcategory=\"Audio-visual\" group=\"RGB LED Module\"\n\n        //% color=#2699BF blockGap=10\n\n        setPin(pin: DigitalPin): void {\n\n            this.pin = pin;\n\n            pins.digitalWritePin(this.pin, 0);\n\n            // don't yield to avoid races on initialization\n\n        }\n\n\n\n\n\n\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n\n            if (this._mode === NeoPixelMode.RGB_RGB) {\n\n                this.buf[offset + 0] = red;\n\n                this.buf[offset + 1] = green;\n\n            } else {\n\n                this.buf[offset + 0] = green;\n\n                this.buf[offset + 1] = red;\n\n            }\n\n            this.buf[offset + 2] = blue;\n\n        }\n\n\n\n        private setAllRGB(rgb: number) {\n\n            let red = unpackR(rgb);\n\n            let green = unpackG(rgb);\n\n            let blue = unpackB(rgb);\n\n\n\n            const br3 = this.brightness;\n\n            if (br3 < 255) {\n\n                red = (red * br3) >> 8;\n\n                green = (green * br3) >> 8;\n\n                blue = (blue * br3) >> 8;\n\n            }\n\n            const end3 = this.start + this._length;\n\n            const stride6 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n\n            for (let i5 = this.start; i5 < end3; ++i5) {\n\n                this.setBufferRGB(i5 * stride6, red, green, blue)\n\n            }\n\n        }\n\n        private setAllW(white: number) {\n\n            if (this._mode !== NeoPixelMode.RGBW)\n\n                return;\n\n\n\n            let br4 = this.brightness;\n\n            if (br4 < 255) {\n\n                white = (white * br4) >> 8;\n\n            }\n\n            let buf8 = this.buf;\n\n            let end4 = this.start + this._length;\n\n            for (let i6 = this.start; i6 < end4; ++i6) {\n\n                let ledoffset3 = i6 * 4;\n\n                buf8[ledoffset3 + 3] = white;\n\n            }\n\n        }\n\n        private setPixelRGB(pixeloffset: number, rgb: number): void {\n\n            if (pixeloffset < 0\n\n                || pixeloffset >= this._length)\n\n                return;\n\n\n\n            let stride7 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n\n            pixeloffset = (pixeloffset + this.start) * stride7;\n\n\n\n            let red2 = unpackR(rgb);\n\n            let green2 = unpackG(rgb);\n\n            let blue2 = unpackB(rgb);\n\n\n\n            let br5 = this.brightness;\n\n            if (br5 < 255) {\n\n                red2 = (red2 * br5) >> 8;\n\n                green2 = (green2 * br5) >> 8;\n\n                blue2 = (blue2 * br5) >> 8;\n\n            }\n\n            this.setBufferRGB(pixeloffset, red2, green2, blue2)\n\n        }\n\n        private setPixelW(pixeloffset: number, white: number): void {\n\n            if (this._mode !== NeoPixelMode.RGBW)\n\n                return;\n\n\n\n            if (pixeloffset < 0\n\n                || pixeloffset >= this._length)\n\n                return;\n\n\n\n            pixeloffset = (pixeloffset + this.start) * 4;\n\n\n\n            let br6 = this.brightness;\n\n            if (br6 < 255) {\n\n                white = (white * br6) >> 8;\n\n            }\n\n            let buf9 = this.buf;\n\n            buf9[pixeloffset + 3] = white;\n\n        }\n\n    }\n\n\n\n    /**\n    \n     * Create a new NeoPixel driver for `numleds` LEDs.\n    \n     * @param pin the pin where the neopixel is connected.\n    \n     * @param numleds number of leds in the strip, eg: 8,30,60,64\n    \n     */\n\n    //% blockId=\"neopixel_create\" block=\"Set color to using the LED ring-light port %neopixelpin \"\n\n    //% parts=\"neopixel\" subcategory=\"Audio-visual\" group=\"RGB LED Module\"\n\n    //% neopixelpin.fieldEditor=\"gridpicker\"\n\n    //% neopixelpin.fieldOptions.width=220\n\n    //% neopixelpin.fieldOptions.columns=2\n\n    //% weight=18\n\n    //% trackArgs=0,2\n\n    //% blockSetVariable=strip\n\n    //% color=#2699BF blockGap=10\n\n    //% weight=51\n\n    export function create(neopixelpin: Write_pin): Strip {\n\n        let strip2 = new Strip();\n\n        let stride8 = NeoPixelMode.RGBW ? 4 : 3;\n\n        strip2.buf = pins.createBuffer(8 * stride8);\n\n        strip2.start = 0;\n\n        strip2._length = 8;\n\n        strip2._mode = NeoPixelMode.RGB;\n\n        strip2._matrixWidth = 0;\n\n        strip2.brightness = 10;\n        strip2.lastrgb = 16777215;\n\n        if (neopixelpin == 1) {\n\n            strip2.setPin(DigitalPin.P0);\n\n        }\n\n        if (neopixelpin == 2) {\n\n            strip2.setPin(DigitalPin.P16);\n\n        }\n\n        if (neopixelpin == 3) {\n\n            strip2.setPin(DigitalPin.P1);\n\n        }\n\n        if (neopixelpin == 4) {\n\n            strip2.setPin(DigitalPin.P12);\n\n        }\n\n        if (neopixelpin == 5) {\n\n            strip2.setPin(DigitalPin.P2);\n\n        }\n\n        if (neopixelpin == 6) {\n\n            strip2.setPin(DigitalPin.P8);\n\n        }\n\n\n\n        return strip2;\n\n    }\n\n\n\n    /**\n    \n     * Converts red, green, blue channels into a RGB color\n    \n     * @param red value of the red channel between 0 and 255. eg: 255\n    \n     * @param green value of the green channel between 0 and 255. eg: 255\n    \n     * @param blue value of the blue channel between 0 and 255. eg: 255\n    \n     */\n\n    //% blockId=\"neopixel_rgb\" block=\"red %red|green %green|blue %blue\"\n\n    //% parts=\"neopixel\" subcategory=\"Audio-visual\" group=\"RGB LED Module\"\n\n    //% weight=12\n\n    //% color=#2699BF blockGap=10\n\n    export function rgb(red: number, green: number, blue: number): number {\n\n        return packRGB(red, green, blue);\n\n    }\n\n\n\n    /**\n    \n     * Gets the RGB value of a known color\n    \n    */\n\n    //% blockId=\"neopixel_colors\" block=\"%color\"\n\n    //% parts=\"neopixel\" subcategory=\"Audio-visual\" group=\"RGB LED Module\"\n\n    //% weight=13\n\n    //% color=#2699BF blockGap=10\n\n    export function colors(color: NeoPixelColors): number {\n\n        return color;\n\n    }\n\n\n\n    function packRGB(a: number, b: number, c: number): number {\n\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n\n    }\n\n\n\n    function unpackR(rgb: number): number {\n\n        let r3 = (rgb >> 16) & 0xFF;\n\n        return r3;\n\n    }\n\n\n\n    function unpackG(rgb: number): number {\n\n        let g3 = (rgb >> 8) & 0xFF;\n\n        return g3;\n\n    }\n\n\n\n    function unpackB(rgb: number): number {\n\n        let b3 = (rgb) & 0xFF;\n\n        return b3;\n\n    }\n\n\n\n    export function hsl(h: number, s: number, l: number): number {\n\n        h = Math.round(h);\n\n        s = Math.round(s);\n\n        l = Math.round(l);\n\n\n\n        h = h % 360;\n\n        s = Math.clamp(0, 99, s);\n\n        l = Math.clamp(0, 99, l);\n\n        let c2 = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\n\n        let h12 = Math.idiv(h, 60);//[0,6]\n\n        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]\n\n        let temp = Math.abs((((h12 % 2) << 8) + h22) - 256);\n\n        let x = (c2 * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n\n        let r$: number;\n\n        let g$: number;\n\n        let b$: number;\n\n        if (h12 == 0) {\n\n            r$ = c2; g$ = x; b$ = 0;\n\n        } else if (h12 == 1) {\n\n            r$ = x; g$ = c2; b$ = 0;\n\n        } else if (h12 == 2) {\n\n            r$ = 0; g$ = c2; b$ = x;\n\n        } else if (h12 == 3) {\n\n            r$ = 0; g$ = x; b$ = c2;\n\n        } else if (h12 == 4) {\n\n            r$ = x; g$ = 0; b$ = c2;\n\n        } else if (h12 == 5) {\n\n            r$ = c2; g$ = 0; b$ = x;\n\n        }\n\n        let m2 = Math.idiv((Math.idiv((l * 2 << 8), 100) - c2), 2);\n\n        let r4 = r$ + m2;\n\n        let g4 = g$ + m2;\n\n        let b4 = b$ + m2;\n\n        return packRGB(r4, g4, b4);\n\n    }\n\n\n\n    export enum HueInterpolationDirection {\n\n        Clockwise,\n\n        CounterClockwise,\n\n        Shortest\n\n    }\n\n    /**\n    \n    * show text in OLED\n    \n    * @param oled_x is X alis, eg: 0\n    \n    * @param oled_y is Y alis, eg: 0\n    \n    * @param s is the text will be show, eg: 'Hello!'\n    \n    */\n\n    //% blockId=\"OLED12864_I2C_SHOWSTRING1\" block=\"Display text – please choose location %oled| text%s\"\n\n    //% parts=OLED12864_I2C trackArgs=0\n\n    //% oled.fieldEditor=\"gridpicker\"\n\n    //% oled.fieldOptions.width=320\n\n    //% oled.fieldOptions.columns=13\n\n    //% group=\"OLED Module\" subcategory=\"Audio-visual\"\n\n    //% weight=10 blockGap=10 color=#0855AA\n\n    export function showString(oled: Oled, s: string, color: number = 1) {\n\n        let oled_x = oled % 13;\n\n        let oled_y = Math.floor(oled / 13);\n\n        let crror = 0\n\n        let col2 = 0\n\n        let q = 0\n\n        let ind2 = 0\n\n        let firstoledinit = 0\n\n        if (pins.i2cReadNumber(_I2CAddr, NumberFormat.Int8LE) == 67) {\n\n            init();\n\n        }\n\n        else {\n\n            for (let r = 0; r < s.length; r++) {\n\n                q = font[s.charCodeAt(r)]\n\n                for (let o = 0; o < 5; o++) {\n\n                    col2 = 0\n\n                    for (let p = 0; p < 5; p++) {\n\n                        if (q & (1 << (5 * o + p)))\n\n                            col2 |= (1 << (p + 1))\n\n                    }\n\n                    ind2 = (oled_x + r) * 5 * (_ZOOM + 1) + oled_y * 128 + o * (_ZOOM + 1) + 1\n\n                    if (color == 0)\n\n                        col2 = 255 - col2\n\n                    _screen[ind2] = col2\n\n                    if (_ZOOM)\n\n                        _screen[ind2 + 1] = col2\n\n                }\n\n            }\n\n            set_pos(oled_x * 5, oled_y)\n\n            let ind02 = oled_x * 5 * (_ZOOM + 1) + oled_y * 128\n\n            let buf72 = _screen.slice(ind02, ind2 + 1)\n\n            buf72[0] = 0x40\n\n            pins.i2cWriteBuffer(_I2CAddr, buf72)\n\n        }\n\n    }\n\n\n\n    /**\n    \n     * show a number in OLED\n    \n     * @param olednum_x is X alis, eg: 0\n    \n     * @param olednum_y is Y alis, eg: 0\n    \n     * @param num is the number will be show, eg: 12\n    \n     * @param color is number color, eg: 1\n    \n     */\n\n    //% blockId=\"OLED12864_I2C_NUMBER\" block=\"Display number – please choose location%oled| number%num\"\n\n    //% parts=OLED12864_I2C trackArgs=0\n\n    //% olednum.fieldEditor=\"gridpicker\"\n\n    //% olednum.fieldOptions.width=320\n\n    //% olednum.fieldOptions.columns=13\n\n    //% group=\"OLED Module\" subcategory=\"Audio-visual\"\n\n    //% weight=9 blockGap=10 color=#0855AA\n\n    export function showNumber(olednum: Oled, num: number, color: number = 1) {\n\n\n\n        let olednum_x = 0\n\n        let olednum_y = 0\n\n        olednum_x = Math.floor(olednum / 13);\n\n        olednum_y = olednum % 13;\n\n        showString(olednum, num.toString(), color)\n\n    }\n\n\n\n\n\n    export function draw() {\n\n        set_pos()\n\n        pins.i2cWriteBuffer(_I2CAddr, _screen)\n\n    }\n\n    /**\n     * show text in OLED\n     * @param x is X alis, eg: 0\n     * @param y is Y alis, eg: 0\n     * @param s is the text will be show, eg: 'Hello!'\n     * @param color is string color, eg: 1\n     */\n    //% blockId=\"OLED12864_I2C_SHOWSTRINGxy\" block=\"Display string at x %x|y %y|at %s|color %color\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED Module\" subcategory=\"Audio-visual\"\n    //% weight=80 blockGap=10 color=#0855AA\n    export function showStringxy(x: number, y: number, s: string, color: number = 1) {\n        let col = 0\n        let e = 0\n        let ind = 0\n        for (let f = 0; f < s.length; f++) {\n            e = font[s.charCodeAt(f)]\n            for (let g = 0; g < 5; g++) {\n                col = 0\n                for (let h = 0; h < 5; h++) {\n                    if (e & (1 << (5 * g + h)))\n                        col |= (1 << (h + 1))\n                }\n                ind = (x + f) * 5 * (_ZOOM + 1) + y * 128 + g * (_ZOOM + 1) + 1\n                if (color == 0)\n                    col = 255 - col\n                _screen[ind] = col\n                if (_ZOOM)\n                    _screen[ind + 1] = col\n            }\n        }\n        set_pos(x * 5, y)\n        let ind0 = x * 5 * (_ZOOM + 1) + y * 128\n        let buf7 = _screen.slice(ind0, ind + 1)\n        buf7[0] = 0x40\n        pins.i2cWriteBuffer(_I2CAddr, buf7)\n    }\n\n    /**\n     * show a number in OLED\n     * @param x is X alis, eg: 0\n     * @param y is Y alis, eg: 0\n     * @param num is the number will be show, eg: 12\n     * @param color is number color, eg: 1\n     */\n    //% blockId=\"OLED12864_I2C_NUMBERxy\" block=\"Display number at x %x|y %y|number %num|color %color\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED Module\" subcategory=\"Audio-visual\"\n    //% weight=80 blockGap=10 color=#0855AA\n    export function showNumberxy(x: number, y: number, num: number, color: number = 1) {\n        showStringxy(x, y, num.toString(), color)\n    }\n\n\n    /**\n    \n     * clear screen\n    \n     */\n\n    //% blockId=\"OLED12864_I2C_CLEAR\" block=\"clear\"\n\n    //% parts=OLED12864_I2C trackArgs=0\n\n    //% group=\"OLED Module\" subcategory=\"Audio-visual\"\n\n    //% weight=8 blockGap=10 color=#0855AA\n\n    export function clear() {\n\n        _screen.fill(0)\n\n        _screen[0] = 0x40\n\n        draw()\n\n    }\n\n\n\n    /**\n    \n     * OLED initialize\n    \n     * @param addr is i2c addr, eg: 60\n    \n     */\n\n    //% blockId=\"OLED12864_I2C_init\" block=\"Initialize OLED \"\n\n    //% parts=OLED12864_I2C trackArgs=0\n\n    //% weight=11 blockGap=10\n\n    //% group=\"OLED Module\" subcategory=\"Audio-visual\"\n\n    //% blockGap=10  color=#0855AA\n\n    export function init() {\n\n        _I2CAddr = 60;\n\n        cmd1(0xAE)       // SSD1306_DISPLAYOFF\n\n        cmd1(0xA4)       // SSD1306_DISPLAYALLON_RESUME\n\n        cmd2(0xD5, 0xF0) // SSD1306_SETDISPLAYCLOCKDIV\n\n        cmd2(0xA8, 0x3F) // SSD1306_SETMULTIPLEX\n\n        cmd2(0xD3, 0x00) // SSD1306_SETDISPLAYOFFSET\n\n        cmd1(0 | 0x0)    // line #SSD1306_SETSTARTLINE\n\n        cmd2(0x8D, 0x14) // SSD1306_CHARGEPUMP\n\n        cmd2(0x20, 0x00) // SSD1306_MEMORYMODE\n\n        cmd3(0x21, 0, 127) // SSD1306_COLUMNADDR\n\n        cmd3(0x22, 0, 63)  // SSD1306_PAGEADDR\n\n        cmd1(0xa0 | 0x1) // SSD1306_SEGREMAP\n\n        cmd1(0xc8)       // SSD1306_COMSCANDEC\n\n        cmd2(0xDA, 0x12) // SSD1306_SETCOMPINS\n\n        cmd2(0x81, 0xCF) // SSD1306_SETCONTRAST\n\n        cmd2(0xd9, 0xF1) // SSD1306_SETPRECHARGE\n\n        cmd2(0xDB, 0x40) // SSD1306_SETVCOMDETECT\n\n        cmd1(0xA6)       // SSD1306_NORMALDISPLAY\n\n        cmd2(0xD6, 1)    // zoom on\n\n        cmd1(0xAF)       // SSD1306_DISPLAYON\n\n        clear()\n\n        _ZOOM = 1\n\n    }\n\n    //% blockId=\"laser_controller\" block=\"Laser %laserpin switch %laserState || Laser %intensity\"\n\n    //% laserState.shadow=\"toggleOnOff\"\n\n    //% weight=25\n\n    //% laserpin.fieldEditor=\"gridpicker\"\n\n    //% laserpin.fieldOptions.width=220\n\n    //% laserpin.fieldOptions.columns=2\n\n    //% intensity.min=0 intensity.max=1023\n\n    //% expandableArgumentMode=\"toggle\"\n\n    //% subcategory=\"Audio-visual\" group=\"Laser Module\"\n\n    export function laserController(laserpin: Write_pin, laserState: boolean, intensity: number = 1023): void {\n\n        let pin79\n\n        if (laserpin == 1) {\n\n\n\n            pin79 = AnalogPin.P0;\n\n        }\n\n        if (laserpin == 2) {\n\n            pin79 = AnalogPin.P16;\n\n        }\n\n        if (laserpin == 3) {\n\n            pin79 = AnalogPin.P1;\n\n        }\n\n        if (laserpin == 4) {\n\n\n\n            pin79 = AnalogPin.P12;\n\n        }\n\n        if (laserpin == 5) {\n\n            pin79 = AnalogPin.P2;\n\n        }\n\n        if (laserpin == 6) {\n\n            pin79 = AnalogPin.P8;\n\n        }\n\n        if (laserState) {\n\n            pins.analogSetPeriod(pin79, 1023);\n\n            pins.analogWritePin(pin79, Math.map(intensity, 0, 1023, 0, 1023));\n\n        }\n\n        else {\n\n            pins.analogWritePin(pin79, 0);\n\n            intensity = 0;\n\n        }\n\n    }\n\n    /////////////////录音模块///////////////////\n\n\n    //% blockId=\"record_id\" block=\"Recording Module play %recordID \"\n\n    //% magState.shadow=\"toggleOnOff\"\n\n    //% weight=2\n\n    //% recordID.fieldEditor=\"gridpicker\"\n\n    //% recordID.fieldOptions.width=220\n\n    //% recordID.fieldOptions.columns=2\n\n    //% expandableArgumentMode=\"toggle\"\n\n    //% group=\"Recording Module\" subcategory=\"Audio-visual\"\n\n    export function Record_id(recordID: Record_list): void {\n        pins.i2cWriteNumber(0x18, recordID, NumberFormat.UInt8BE)\n    }\n\n\n\n    enum Recodpin {\n        //% block=\"(P0,P13)\"\n\n        rc1 = 13,\n        //% block=\"(P1,P14)\"\n\n        rc2 = 114,\n\n        //% block=\"(P2,P15)\"\n\n        rc3 = 215\n    }\n\n}\n","pxt.json":"{\n    \"name\": \"icreaterobot\",\n    \"version\": \"1.1.6\",\n    \"description\": \"\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"ws2812b\": \"github:microsoft/pxt-ws2812b#v0.1.1\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"_locales/zh/icreaterobot-strings.json\",\n        \"_locales/ru/icreaterobot-strings.json\",\n        \"_locales/ja/icreaterobot-strings.json\",\n        \"_locales/ko/icreaterobot-strings.json\",\n        \"_locales/fr/icreaterobot-strings.json\",\n        \"_locales/ar/icreaterobot-strings.json\",\n        \"_locales/de/icreaterobot-strings.json\",\n        \"_locales/el/icreaterobot-strings.json\",\n        \"_locales/zh-TW/icreaterobot-strings.json\",\n        \"heart.cpp\",\n        \"MAX30105.cpp\",\n        \"MAX30105.h\",\n        \"shims.d.ts\",\n        \"enums.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.57\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n    /**\n     * Andy England @ SparkFun Electronics\n     * June 4, 2019\n     * https://github.com/sparkfun/pxt-gator-particle\n     *\n     * Development environment specifics:\n     * Written in Microsoft PXT\n     * Tested with a SparkFun Gator:Particle Sensor\n     *\n     * This code is released under the [MIT License](http://opensource.org/licenses/MIT).\n     * Please review the LICENSE.md file included with this example. If you have any questions\n     * or concerns with licensing, please contact techsupport@sparkfun.com.\n     * Distributed as-is; no warranty is given.\n     */\n\ndeclare namespace Microbit {\n}\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}